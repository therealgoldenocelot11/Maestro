var mn=Object.defineProperty;var gn=(u,e,t)=>e in u?mn(u,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):u[e]=t;var v=(u,e,t)=>gn(u,typeof e!="symbol"?e+"":e,t);import{P as yt,O as Ls,E as Ve,Q as ge,a as Ue,V as G,A as Is,l as Fe,L as yn,M as Ae,b as as,c as ks,d as It,e as xn,f as lt,D as cs,S as kt,B as wn,g as me,C as bn,h as An,i as Tn,T as vn,j as Ds,k as xt,m as Mn,n as Re,o as at,p as Dt,q as Sn,r as De,s as ze,t as Oe,u as gs,v as Os,w as se,x as En,R as _n,y as Pn,z as Rn,F as Ze,G as Vt,H as Cn,I as Ln,J as In,K as kn,N as Dn,W as Fs,U as On,X as Fn,Y as Ne,Z as Nn,_ as ht,$ as tt,a0 as wt,a1 as Ot,a2 as je,a3 as Zt,a4 as $t,a5 as Ie,a6 as oe,a7 as fe,a8 as Bn,a9 as st,aa as Jt,ab as ut,ac as _t,ad as ls,ae as hs,af as Ns,ag as Bs,ah as Vs,ai as Pe,aj as Vn,ak as Ke,al as Z,am as Us,an as zs,ao as es,ap as Pt,aq as ts,ar as Un,as as ss,at as js,au as Ge,av as zn,aw as jn,ax as Gn,ay as Hn,az as Gs,aA as Wn,aB as Xn,aC as Kn,aD as ns,aE as Hs,aF as qn,aG as Ut,aH as Yn,aI as Qn,aJ as Ws,aK as Zn,aL as $n,aM as Jn,aN as ei,aO as ti,aP as si,aQ as zt,aR as Ye,aS as ni,aT as ii,aU as ri,aV as oi,aW as ai,aX as ci,aY as li,aZ as nt,a_ as Je,a$ as ys,b0 as hi,b1 as Rt,b2 as Ft,b3 as ui,b4 as Xs,b5 as Ks,b6 as us,b7 as di,b8 as pi,b9 as fi,ba as mi,bb as qe,bc as xs,bd as gi}from"./index-Ci6giZe7.js";/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
 */class dt{perspectiveCamera(e={}){return dt.Perspective(e)}orthographicCamera(e={}){return dt.Orthographic(e)}static Perspective(e={}){const{fov:t=50,aspect:s=window.innerWidth/window.innerHeight,near:n=.1,far:i=2e3,x:r=0,y:a=5,z:o=25}=e,c=new yt(t,s,n,i);return c.position.set(r,a,o),c}static Orthographic(e={}){const t=window.innerWidth,s=window.innerHeight,{left:n=t/-2,right:i=t/2,top:r=s/2,bottom:a=s/-2,near:o=1,far:c=1e3,x:h=0,y:l=0,z:d=10}=e,p=new Ls(n,i,r,a,o,c);return p.position.set(h,l,d),p}}const yi="0.0.7";/**
 * @package      npmjs.com/package/@yandeu/events (events.min.js)
 *
 * @author       Arnout Kazemier (https://github.com/3rd-Eden)
 * @copyright    Copyright (c) 2014 Arnout Kazemier
 * @license      {@link https://github.com/primus/eventemitter3/blob/master/LICENSE|MIT}
 *
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2021 Yannick Deubel; Project Url: https://github.com/yandeu/events
 * @license      {@link https://github.com/yandeu/events/blob/master/LICENSE|MIT}
 */class xi{constructor(e,t,s=!1){v(this,"fn");v(this,"context");v(this,"once");this.fn=e,this.context=t,this.once=s}}const ws=(u,e,t,s,n)=>{if(typeof t!="function")throw new TypeError("The listener must be a function");const i=new xi(t,s||u,n);return u._events.has(e)?u._events.get(e).fn?u._events.set(e,[u._events.get(e),i]):u._events.get(e).push(i):(u._events.set(e,i),u._eventsCount++),u},Mt=(u,e)=>{--u._eventsCount===0?u._events=new Map:u._events.delete(e)};class Ct{constructor(){v(this,"_events",new Map);v(this,"_eventsCount",0)}static get VERSION(){return yi}eventNames(){return Array.from(this._events.keys())}listeners(e){const t=this._events.get(e);if(!t)return[];if(t.fn)return[t.fn];for(var s=0,n=t.length,i=new Array(n);s<n;s++)i[s]=t[s].fn;return i}listenerCount(e){const t=this._events.get(e);return t?t.fn?1:t.length:0}emit(e,...t){if(!this._events.has(e))return!1;const s=this._events.get(e);let n;if(s.fn)return s.once&&this.removeListener(e,s.fn,void 0,!0),s.fn.call(s.context,...t),!0;{const i=s.length;for(n=0;n<i;n++)s[n].once&&this.removeListener(e,s[n].fn,void 0,!0),s[n].fn.call(s[n].context,...t)}return!0}on(e,t,s){return ws(this,e,t,s,!1)}once(e,t,s){return ws(this,e,t,s,!0)}removeListener(e,t,s,n){if(!this._events.has(e))return this;if(!t)return Mt(this,e),this;const i=this._events.get(e);if(i.fn)i.fn===t&&(!n||i.once)&&(!s||i.context===s)&&Mt(this,e);else{for(var r=0,a=[],o=i.length;r<o;r++)(i[r].fn!==t||n&&!i[r].once||s&&i[r].context!==s)&&a.push(i[r]);a.length?this._events.set(e,a.length===1?a[0]:a):Mt(this,e)}return this}removeAllListeners(e){return e?this._events.delete(e)&&Mt(this,e):(this._events=new Map,this._eventsCount=0),this}get off(){return this.removeListener}get addListener(){return this.on}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
 */class wi{constructor(e,t){v(this,"physics");v(this,"ammo");v(this,"ptr");v(this,"body");v(this,"ignoreScale",!1);v(this,"isSoftBody",!1);v(this,"offset",{x:0,y:0,z:0});v(this,"name");v(this,"errors",[]);v(this,"checkCollisions",!1);v(this,"impact",[]);v(this,"breakable",!1);v(this,"fractureImpulse",1);v(this,"didUpdate",!1);v(this,"skipUpdate",!1);v(this,"_emitUpdateEvents",!1);v(this,"_needUpdate",!1);v(this,"tmpEuler",new Ve);v(this,"tmpQuaternion",new ge);v(this,"tmpBtVector3",new Ammo.btVector3);v(this,"tmpBtVector3_1",new Ammo.btVector3);v(this,"tmpBtQuaternion",new Ammo.btQuaternion(0,0,0,1));v(this,"eventEmitter",new Ct);this.physics=e,this.ammo=t,this.name=t.name}destructor(){this.eventEmitter&&this.eventEmitter.removeAllListeners(),Ammo.destroy(this.tmpBtVector3),Ammo.destroy(this.tmpBtVector3_1),Ammo.destroy(this.tmpBtQuaternion),Ammo.destroy(this.ammo.getCollisionShape()),Ammo.destroy(this.ammo)}setupEventEmitter(){typeof this.eventEmitter>"u"&&(this.eventEmitter=new Ct)}get needUpdate(){return this._needUpdate}set needUpdate(e){!e&&this._needUpdate&&(this.didUpdate=!0),this._needUpdate=e}onUpdateEvent(e,t=!1){this.setupEventEmitter(),this._emitUpdateEvents=!0,t?this.eventEmitter.once("update",()=>{e()}):this.eventEmitter.on("update",()=>{e()})}get on(){return{update:e=>this.onUpdateEvent(e),collision:e=>this.onCollision(e)}}get once(){return{update:e=>this.onUpdateEvent(e,!0)}}onCollision(e){this.checkCollisions=!0,this.physics.collisionEvents.on("collision",t=>{const{bodies:s,event:n}=t;s[0].name===this.name?e(s[1],n):s[1].name===this.name&&e(s[0],n)})}transform(){const e=this.physics.worldTransform;this.ammo.getMotionState().getWorldTransform(e)}refresh(){const e=this.physics.worldTransform;this.ammo.getMotionState().setWorldTransform(e)}setRotation(e,t,s){const n=this.tmpEuler.set(e,t,s),i=this.tmpQuaternion.set(0,0,0,1);i.setFromEuler(n),this.tmpBtQuaternion.setValue(0,0,0,1);const r=this.tmpBtQuaternion;r.setValue(i.x,i.y,i.z,i.w),this.physics.worldTransform.setRotation(r)}get rotation(){let e,t,s;const i=this.physics.worldTransform.getRotation();let r=this.tmpQuaternion.set(i.x(),i.y(),i.z(),i.w());r.w>1&&(r=r.normalize());const a=2*Math.acos(r.w),o=Math.sqrt(1-r.w*r.w);return o<.001?(e=r.x,t=r.y,s=r.z):(e=r.x/o,t=r.y/o,s=r.z/o),{x:e*a,y:t*a,z:s*a}}get quaternion(){const t=this.physics.worldTransform.getRotation();return{x:t.x(),y:t.y(),z:t.z(),w:t.w()}}setPosition(e,t,s){this.physics.worldTransform.getOrigin().setValue(e,t,s)}get position(){const e=this.physics.worldTransform;return{x:e.getOrigin().x(),y:e.getOrigin().y(),z:e.getOrigin().z()}}get velocity(){return{x:this.ammo.getLinearVelocity().x(),y:this.ammo.getLinearVelocity().y(),z:this.ammo.getLinearVelocity().z()}}get angularVelocity(){return{x:this.ammo.getAngularVelocity().x(),y:this.ammo.getAngularVelocity().y(),z:this.ammo.getAngularVelocity().z()}}setVelocity(e,t,s){this.tmpBtVector3.setValue(e,t,s),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityX(e){this.tmpBtVector3.setValue(e,this.velocity.y,this.velocity.z),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityY(e){this.tmpBtVector3.setValue(this.velocity.x,e,this.velocity.z),this.ammo.setLinearVelocity(this.tmpBtVector3)}setVelocityZ(e){this.tmpBtVector3.setValue(this.velocity.x,this.velocity.y,e),this.ammo.setLinearVelocity(this.tmpBtVector3)}setAngularVelocity(e,t,s){this.tmpBtVector3.setValue(e,t,s),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityX(e){this.tmpBtVector3.setValue(e,this.angularVelocity.y,this.angularVelocity.z),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityY(e){this.tmpBtVector3.setValue(this.angularVelocity.x,e,this.angularVelocity.z),this.ammo.setAngularVelocity(this.tmpBtVector3)}setAngularVelocityZ(e){this.tmpBtVector3.setValue(this.angularVelocity.x,this.angularVelocity.y,e),this.ammo.setAngularVelocity(this.tmpBtVector3)}applyForce(e,t,s){this.tmpBtVector3.setValue(e,t,s),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceX(e){this.tmpBtVector3.setValue(e,0,0),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceY(e){this.tmpBtVector3.setValue(0,e,0),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyForceZ(e){this.tmpBtVector3.setValue(0,0,e),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyCentralForce(e,t,s){this.tmpBtVector3.setValue(e,t,s),this.ammo.applyCentralForce(this.tmpBtVector3)}applyCentralImpulse(e,t,s){this.tmpBtVector3.setValue(e,t,s),this.ammo.applyCentralImpulse(this.tmpBtVector3)}applyCentralLocalForce(e,t,s){this.tmpBtVector3.setValue(e,t,s),this.ammo.applyCentralLocalForce(this.tmpBtVector3)}applyImpulse(e,t){this.tmpBtVector3.setValue(e.x||0,e.y||0,e.z||0),this.tmpBtVector3_1.setValue(t.x||0,t.y||0,t.z||0),this.ammo.applyImpulse(this.tmpBtVector3,this.tmpBtVector3_1)}applyLocalTorque(e,t,s){this.tmpBtVector3.setValue(e,t,s),this.ammo.applyLocalTorque(this.tmpBtVector3)}applyTorque(e,t,s){this.tmpBtVector3.setValue(e,t,s),this.ammo.applyTorque(this.tmpBtVector3)}applyTorqueImpulse(e,t,s){this.tmpBtVector3.setValue(e,t,s),this.ammo.applyTorqueImpulse(this.tmpBtVector3)}setCollisionFlags(e){this.ammo.setCollisionFlags(e)}getCollisionFlags(){return this.ammo.getCollisionFlags()}setRestitution(e){this.ammo.setRestitution(e)}setBounciness(e){this.setRestitution(e)}setFriction(e){this.ammo.setFriction(e)}setDamping(e,t){this.ammo.setDamping(e,t)}setGravity(e,t,s){this.tmpBtVector3.setValue(e,t,s),this.ammo.setGravity(this.tmpBtVector3)}setLinearFactor(e,t,s){this.tmpBtVector3.setValue(e,t,s),this.ammo.setLinearFactor(this.tmpBtVector3)}setAngularFactor(e,t,s){this.tmpBtVector3.setValue(e,t,s),this.ammo.setAngularFactor(this.tmpBtVector3)}setCcdMotionThreshold(e){this.ammo.setCcdMotionThreshold(e)}setCcdSweptSphereRadius(e){this.ammo.setCcdSweptSphereRadius(e)}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2021 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
 */class bi extends Ue{constructor(){super();v(this,"ptr");v(this,"isMesh",!1);v(this,"isExtendedObject3D",!0);v(this,"isGroup",!1);v(this,"vector3",new G);v(this,"shape");v(this,"name");v(this,"body");v(this,"hasBody",!1);v(this,"fragmentDepth",0);v(this,"breakable",!1);v(this,"fractureImpulse",1);v(this,"children",[]);v(this,"parent",null);v(this,"_currentAnimation","");v(this,"_animationActions",new Map);v(this,"_animationMixer");this.name=`object-${this.id}`}get world(){return{theta:this.worldTheta,phi:this.worldPhi}}get worldTheta(){return this.getWorldDirection(this.vector3),Math.atan2(this.vector3.x,this.vector3.z)}get worldPhi(){return this.getWorldDirection(this.vector3),Math.acos(this.vector3.y)}set animationMixer(t){this._animationMixer=t}get animationMixer(){return this._animationMixer||(this._animationMixer=new Is(this)),this._animationMixer}get anims(){return{current:this._currentAnimation,add:(t,s)=>this._animsAdd(t,s),get:t=>this._animsGet(t),play:(t,s=500,n=!0)=>this._animsPlay(t,s,n),mixer:this.animationMixer}}get animation(){return Fe('Please use "anims" instead of "animation"'),this.anims}_animsAdd(t,s){this._animationActions.set(t,this.animationMixer.clipAction(s))}_animsGet(t){const s=this._animationActions.get(t);return s||Fe(`Animation(${t}) not found!`),s}_animsPlay(t,s=500,n=!0){const i=this._animationActions.get(t),r=this._animationActions.get(this._currentAnimation);i&&(i.reset(),r&&(i.crossFadeFrom(r,s/1e3,!0),i.clampWhenFinished=!0),n||i.setLoop(yn,0),i.play()),this._currentAnimation=t}setAction(t){Fe(`setAction(${t}) is deprecated. Use animation.play(${t}) instead!`)}traverse(t){super.traverse(t)}traverseVisible(t){super.traverseVisible(t)}traverseAncestors(t){super.traverseAncestors(t)}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2021 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
 */class qs extends Ae{constructor(t,s){super(t,s);v(this,"ptr");v(this,"isExtendedMesh",!0);v(this,"isGroup",!1);v(this,"vector3",new G);v(this,"shape");v(this,"name");v(this,"body");v(this,"hasBody",!1);v(this,"fragmentDepth",0);v(this,"breakable",!1);v(this,"fractureImpulse",1);this.name=`object-${this.id}`}get world(){return{theta:this.worldTheta,phi:this.worldPhi}}get worldTheta(){return this.getWorldDirection(this.vector3),Math.atan2(this.vector3.x,this.vector3.z)}get worldPhi(){return this.getWorldDirection(this.vector3),Math.acos(this.vector3.y)}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
 */class Ai{constructor(e,t){v(this,"factory");v(this,"addExisting");this.factory=e,this.addExisting=t}addPlane(e={},t={}){const s=this.factory.add.plane(e,t);return this.addExisting(s,e),s}addSphere(e={},t={}){const s=this.factory.add.sphere(e,t);return this.addExisting(s,e),s}addBox(e={},t={}){const s=this.factory.add.box(e,t);return this.addExisting(s,e),s}addGround(e,t={}){const s=this.factory.add.ground(e,t),n={...e,mass:0,collisionFlags:1};return this.addExisting(s,n),s}addCapsule(e={},t={}){const s=this.factory.add.capsule(e,t);return this.addExisting(s,e),s}addCylinder(e={},t={}){const s=this.factory.add.cylinder(e,t);return this.addExisting(s,e),s}addCone(e={},t={}){const s=this.factory.add.cone(e,t);return this.addExisting(s,e),s}addTorus(e={},t={}){const s=this.factory.add.torus(e,t);return this.addExisting(s,e),s}addExtrude(e,t={}){const s=this.factory.add.extrude(e,t);return s.translateX(1),this.addExisting(s),s}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
 */class Ti{constructor(e,t){v(this,"worldTransform");v(this,"physicsWorld");v(this,"tmpBtVector3",new Ammo.btVector3);this.worldTransform=e,this.physicsWorld=t}toAmmoV3(e,t=0){return new Ammo.btVector3(typeof(e==null?void 0:e.x)<"u"?e.x:t,typeof(e==null?void 0:e.y)<"u"?e.y:t,typeof(e==null?void 0:e.z)<"u"?e.z:t)}get addConstraints(){return{lock:(e,t,s)=>this.lock(e,t,s),fixed:(e,t,s)=>this.fixed(e,t,s),pointToPoint:(e,t,s,n)=>this.pointToPoint(e,t,s,n),hinge:(e,t,s,n)=>this.hinge(e,t,s,n),slider:(e,t,s={},n)=>this.slider(e,t,s,n),spring:(e,t,s={},n)=>this.spring(e,t,s,n),coneTwist:(e,t,s={frameA:{},frameB:{}},n)=>this.coneTwist(e,t,s,n),dof:(e,t,s,n)=>this.dof(e,t,s,n)}}getTransform(e,t,s={x:0,y:0,z:0},n=!1){s={x:0,y:0,z:0,...s};const i=(a,o)=>{var c=(a.x()-o.x())/2+s.x,h=(a.y()-o.y())/2+s.y,l=(a.z()-o.z())/2+s.z;return new Ammo.btVector3(c,h,l)},r=new Ammo.btTransform;if(r.setIdentity(),n){const a=i(e.getWorldTransform().getOrigin(),t.getWorldTransform().getOrigin()),o=new Ammo.btTransform;o.setIdentity(),o.setOrigin(a);const c=e.getCenterOfMassTransform().inverse().op_mul(t.getWorldTransform());return c.op_mul(o),{transformA:c,transformB:o}}else return r.setOrigin(new Ammo.btVector3(s.x,s.y,s.z)),{transformA:e.getCenterOfMassTransform().inverse().op_mul(t.getWorldTransform()).op_mul(r),transformB:r}}lock(e,t,s=!0){const n={x:0,y:0,z:0};return this.dof(e,t,{angularLowerLimit:n,angularUpperLimit:n},s)}fixed(e,t,s=!0){const n=this.getTransform(e.ammo,t.ammo);n.transformA.setRotation(e.ammo.getWorldTransform().getRotation()),n.transformB.setRotation(t.ammo.getWorldTransform().getRotation());const i=new Ammo.btFixedConstraint(e.ammo,t.ammo,n.transformA,n.transformB);return this.physicsWorld.addConstraint(i,s),i}pointToPoint(e,t,s={},n=!0){const{pivotA:i,pivotB:r}=s,a=new Ammo.btVector3((i==null?void 0:i.x)||0,(i==null?void 0:i.y)||0,(i==null?void 0:i.z)||0),o=new Ammo.btVector3((r==null?void 0:r.x)||0,(r==null?void 0:r.y)||0,(r==null?void 0:r.z)||0),c=new Ammo.btPoint2PointConstraint(e.ammo,t.ammo,a,o);return this.physicsWorld.addConstraint(c,n),c}hinge(e,t,s={},n=!0){const{pivotA:i,pivotB:r,axisA:a,axisB:o}=s,c=new Ammo.btVector3((i==null?void 0:i.x)||0,(i==null?void 0:i.y)||0,(i==null?void 0:i.z)||0),h=new Ammo.btVector3((r==null?void 0:r.x)||0,(r==null?void 0:r.y)||0,(r==null?void 0:r.z)||0),l=new Ammo.btVector3((a==null?void 0:a.x)||0,(a==null?void 0:a.y)||0,(a==null?void 0:a.z)||0),d=new Ammo.btVector3((o==null?void 0:o.x)||0,(o==null?void 0:o.y)||0,(o==null?void 0:o.z)||0),p=new Ammo.btHingeConstraint(e.ammo,t.ammo,c,h,l,d,!0);return this.physicsWorld.addConstraint(p,n),p}slider(e,t,s={},n=!0){const i=this.getTransform(e.ammo,t.ammo),{frameA:r={},frameB:a={},linearLowerLimit:o=0,linearUpperLimit:c=0,angularLowerLimit:h=0,angularUpperLimit:l=0}=s,d=i.transformA.getRotation();d.setEulerZYX(r.x||0,r.y||0,r.z||0),i.transformA.setRotation(d);const p=i.transformB.getRotation();p.setEulerZYX(a.x||0,a.y||0,a.z||0),i.transformB.setRotation(p);const w=new Ammo.btSliderConstraint(e.ammo,t.ammo,i.transformA,i.transformB,!0);return w.setLowerLinLimit(o),w.setUpperLinLimit(c),w.setLowerAngLimit(h),w.setUpperAngLimit(l),this.physicsWorld.addConstraint(w,n),w}spring(e,t,s={},n=!0){const{stiffness:i=50,damping:r=.01,angularLock:a=!1,linearLowerLimit:o={},linearUpperLimit:c={},angularLowerLimit:h={},angularUpperLimit:l={},offset:d={},center:p=!1,enableSpring:w=!0}=s,x={x:0,y:0,z:0,...d},y=this.getTransform(e.ammo,t.ammo,x,p),T=new Ammo.btGeneric6DofSpringConstraint(e.ammo,t.ammo,y.transformA,y.transformB,!0);this.tmpBtVector3.setValue(o.x||0,o.y||0,o.z||0),T.setLinearLowerLimit(this.tmpBtVector3),this.tmpBtVector3.setValue(c.x||0,c.y||0,c.z||0),T.setLinearUpperLimit(this.tmpBtVector3),a?(this.tmpBtVector3.setValue(0,0,0),T.setAngularLowerLimit(this.tmpBtVector3),T.setAngularUpperLimit(this.tmpBtVector3)):(console.log(h,l),T.setAngularLowerLimit(this.toAmmoV3(h,-Math.PI)),T.setAngularUpperLimit(this.toAmmoV3(l,Math.PI)));for(let _=0;_<3;_++)T.enableSpring(_,w),T.setStiffness(_,i),T.setDamping(_,r);return this.physicsWorld.addConstraint(T,n),T}coneTwist(e,t,s,n=!0){const{frameA:i,frameB:r}=s,a=new Ammo.btTransform;a.setIdentity(),a.getOrigin().setValue((i==null?void 0:i.x)||0,(i==null?void 0:i.y)||0,(i==null?void 0:i.z)||0);const o=new Ammo.btTransform;o.setIdentity(),o.getOrigin().setValue((r==null?void 0:r.x)||0,(r==null?void 0:r.y)||0,(r==null?void 0:r.z)||0),this.getTransform(e.ammo,t.ammo);const c=new Ammo.btConeTwistConstraint(t.ammo,e.ammo,a,o);return c.setAngularOnly(!0),this.physicsWorld.addConstraint(c,n),c}dof(e,t,s={},n=!0){const{offset:i,center:r=!1}=s,a={x:0,y:0,z:0,...i},o=this.getTransform(e.ammo,t.ammo,a,r),c=new Ammo.btGeneric6DofConstraint(e.ammo,t.ammo,o.transformA,o.transformB,!0),{linearLowerLimit:h,linearUpperLimit:l,angularLowerLimit:d,angularUpperLimit:p}=s,w=this.toAmmoV3(h),x=this.toAmmoV3(l),y=this.toAmmoV3(d,-Math.PI),T=this.toAmmoV3(p,Math.PI);return c.setLinearLowerLimit(w),c.setLinearUpperLimit(x),c.setAngularLowerLimit(y),c.setAngularUpperLimit(T),Ammo.destroy(w),Ammo.destroy(x),Ammo.destroy(y),Ammo.destroy(T),this.physicsWorld.addConstraint(c,n),c}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
 */const vi=(u,e)=>{const{radius:t=1,tube:s=.4,tubularSegments:n=8}=u,i=Math.PI,r=n,a=Math.sqrt(2*s*s-2*s*s*Math.cos(2*i/r)),o=new Ammo.btVector3(s,i/r+.5*a,s),c=new Ammo.btCylinderShape(o);c.setMargin(.05);const h=new Ammo.btCompoundShape,l=new Ammo.btVector3(0,0,1),d=new Ammo.btVector3(0,t,0),p=new Ammo.btQuaternion(e.x,e.y,e.z,e.w);for(let w=0;w<r;w++){const x=w*2*i/r,y=d.rotate(l,x),T=new Ammo.btTransform;p.setRotation(l,x+Math.PI/2),T.setIdentity(),T.setOrigin(y),T.setRotation(p),h.addChildShape(T,c)}return h};class Ys{constructor(){v(this,"_defaultMaterial");this._defaultMaterial=new as({color:13421772})}get(){return this._defaultMaterial}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
 */class Qs{constructor(e){v(this,"scene");v(this,"defaultMaterial");v(this,"isHeadless");this.scene=e,this.isHeadless=e==="headless",this.defaultMaterial=new Ys}get make(){return{plane:(e={},t={})=>this.makePlane(e,t),box:(e={},t={})=>this.makeBox(e,t),sphere:(e={},t={})=>this.makeSphere(e,t),capsule:(e={},t={})=>this.makeCapsule(e,t),cylinder:(e={},t={})=>this.makeCylinder(e,t),cone:(e={},t={})=>this.makeCone(e,t),torus:(e={},t={})=>this.makeTorus(e,t),extrude:(e,t={})=>this.makeExtrude(e,t)}}get add(){return{mesh:e=>this.addMesh(e),existing:e=>this.addExisting(e),plane:(e={},t={})=>this.addPlane(e,t),box:(e={},t={})=>this.addBox(e,t),ground:(e,t={})=>this.addGround(e,t),sphere:(e={},t={})=>this.addSphere(e,t),capsule:(e={},t={})=>this.addCapsule(e,t),cylinder:(e={},t={})=>this.addCylinder(e,t),cone:(e={},t={})=>this.addCone(e,t),torus:(e={},t={})=>this.addTorus(e,t),extrude:(e,t={})=>this.addExtrude(e,t),material:(e={})=>this.addMaterial(e)}}addExisting(...e){this.scene!=="headless"&&this.scene.add(...e)}addMesh(e){if(Array.isArray(e))for(let t=0;t<e.length;t++)this.addExisting(e[t]);else this.addExisting(e);return this}createMesh(e,t,s){const{x:n=0,y:i=0,z:r=0}=s;let a;switch(!Array.isArray(t)&&t.type){case"LineBasicMaterial":a=new It(e,t);break;case"PointsMaterial":a=new ks(e,t);break;default:a=new qs(e,t);break}return a.position.set(n,i,r),a.castShadow=a.receiveShadow=!0,a}makeExtrude(e,t){const{x:s,y:n,z:i,name:r,shape:a,autoCenter:o=!0,breakable:c=!1,...h}=e,{depth:l=1,bevelEnabled:d=!1}=h,p=new xn(a,{depth:l,bevelEnabled:d,...h}),w=this.addMaterial(t),x=this.createMesh(p,w,{x:s,y:n,z:i});return o&&x.geometry.center(),x.name=r||`body_id_${x.id}`,x.shape="extrude",x}addExtrude(e,t={}){const s=this.makeExtrude(e,t);return this.addExisting(s),s}makePlane(e,t){const{x:s,y:n,z:i,name:r,breakable:a=!1,...o}=e,c=new lt(o.width||1,o.height||1,o.widthSegments||1,o.heightSegments||1),h=this.addMaterial(t);h.side=cs;const l=this.createMesh(c,h,{x:s,y:n,z:i});return l.name=r||`body_id_${l.id}`,l.shape="plane",l}addPlane(e,t){const s=this.makePlane(e,t);return this.addExisting(s),s}makeSphere(e,t){const{x:s,y:n,z:i,name:r,breakable:a=!1,...o}=e,c=new kt(o.radius||1,o.widthSegments||16,o.heightSegments||12,o.phiStart||void 0,o.phiLength||void 0,o.thetaStart||void 0,o.thetaLength||void 0),h=this.addMaterial(t),l=this.createMesh(c,h,{x:s,y:n,z:i});return l.name=r||`body_id_${l.id}`,l.shape="sphere",l}addSphere(e={},t={}){const s=this.makeSphere(e,t);return this.addExisting(s),s}makeBox(e,t){const{x:s,y:n,z:i,name:r,breakable:a=!1,...o}=e,c=new wn(o.width||1,o.height||1,o.depth||1,o.widthSegments||void 0,o.heightSegments||void 0,o.depthSegments||void 0),h=this.addMaterial(t),l=this.createMesh(c,h,{x:s,y:n,z:i});return l.name=r||`body_id_${l.id}`,l.shape="box",l}addBox(e={},t={}){const s=this.makeBox(e,t);return this.addExisting(s),s}addGround(e,t={}){const s=this.makeBox(e,t);return s.rotateX(me.degToRad(90)),this.addExisting(s),s}makeCapsule(e={},t={}){const{x:s,y:n,z:i,name:r,breakable:a=!1,...o}=e,c=new bn(o.radius||.5,o.length||1,o.capSegments||4,o.radialSegments||16),h=this.addMaterial(t),l=this.createMesh(c,h,{x:s,y:n,z:i});return l.name=r||`body_id_${l.id}`,l.shape="capsule",l}addCapsule(e={},t={}){const s=this.makeCapsule(e,t);return this.addExisting(s),s}makeCylinder(e={},t={}){const{x:s,y:n,z:i,name:r,breakable:a=!1,...o}=e,c=new An(o.radiusTop||1,o.radiusBottom||1,o.height||1,o.radiusSegments||void 0,o.heightSegments||void 0,o.openEnded||void 0,o.thetaStart||void 0,o.thetaLength||void 0),h=this.addMaterial(t),l=this.createMesh(c,h,{x:s,y:n,z:i});return l.name=r||`body_id_${l.id}`,l.shape="cylinder",l}addCylinder(e={},t={}){const s=this.makeCylinder(e,t);return this.addExisting(s),s}makeCone(e={},t={}){const{x:s,y:n,z:i,name:r,breakable:a=!1,...o}=e,c=new Tn(o.radius||1,o.height||1,o.radiusSegments||8,o.heightSegments||1,o.openEnded||!1,o.thetaStart||0,o.thetaLength||2*Math.PI),h=this.addMaterial(t),l=this.createMesh(c,h,{x:s,y:n,z:i});return l.name=r||`body_id_${l.id}`,l.shape="cone",l}addCone(e={},t={}){const s=this.makeCone(e,t);return this.addExisting(s),s}makeTorus(e={},t={}){const{x:s,y:n,z:i,name:r,breakable:a=!1,...o}=e,c=new vn(o.radius||void 0,o.tube||void 0,o.radialSegments||void 0,o.tubularSegments||void 0,o.arc||void 0),h=this.addMaterial(t),l=this.createMesh(c,h,{x:s,y:n,z:i});return l.name=r||`body_id_${l.id}`,l.shape="torus",l}addTorus(e={},t={}){const s=this.makeTorus(e,t);return this.addExisting(s),s}addMaterial(e={}){const t=Object.keys(e)[0];let s;if(this.scene==="headless")return this.defaultMaterial.get();switch(t){case"basic":s=new De(e.basic);break;case"normal":s=new Sn(e.normal);break;case"standard":s=new Dt(e.standard);break;case"lambert":s=new as(e.lambert);break;case"phong":s=new at(e.phong);break;case"physical":typeof e.physical<"u"?s=new Re(e.physical):(Fe("You need to pass parameters to the physical material. (Fallback to default material)"),s=this.defaultMaterial.get());break;case"toon":s=new Mn(e.toon);break;case"line":s=new xt(e.line);break;case"points":s=new Ds(e.points);break;case"custom":s=e.custom||this.defaultMaterial.get();break;default:s=this.defaultMaterial.get();break}return s}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
 */class Mi extends Ct{constructor(){super(...arguments);v(this,"worldTransform");v(this,"physicsWorld")}addCollider(t,s,n){!t.body||!s.body||(t.body.checkCollisions=!0,s.body.checkCollisions=!0,this.on("collision",i=>{var o,c;const{bodies:r,event:a}=i;(o=r[0])!=null&&o.name&&((c=r[1])!=null&&c.name)&&(t!=null&&t.name)&&(s!=null&&s.name)&&(r[0].name===t.name&&r[1].name===s.name||r[1].name===t.name&&r[0].name===s.name)&&n(a)}))}}/**
 * @author       Kevin Lee (https://github.com/InfiniteLee)
 * @copyright    Copyright (c) 2019 Kevin Lee; Project Url: https://github.com/InfiniteLee/ammo-debug-drawer
 * @license      {@link https://github.com/InfiniteLee/ammo-debug-drawer/blob/master/LICENSE|MPL-2.0}
 */const bs={DrawWireframe:1,DrawOnTop:32768};class Si{constructor(e,t,s={}){v(this,"scene");v(this,"world");v(this,"options");v(this,"debugDrawMode");v(this,"geometry");v(this,"index");v(this,"mesh");v(this,"enabled");v(this,"debugDrawer");v(this,"warnedOnce");this.scene=e,this.world=t,this.options=s,this.debugDrawMode=s.debugDrawMode||bs.DrawWireframe;const n=this.debugDrawMode&bs.DrawOnTop||!1,i=s.maxBufferSize||1e6;this.geometry=new ze;const r=new Float32Array(i*3),a=new Float32Array(i*3);this.geometry.setAttribute("position",new Oe(r,3).setUsage(gs)),this.geometry.setAttribute("color",new Oe(a,3).setUsage(gs)),this.index=0;const o=new xt({vertexColors:!0,depthTest:!n});this.mesh=new Os(this.geometry,o),n&&(this.mesh.renderOrder=999),this.mesh.frustumCulled=!1,this.enabled=!1,this.debugDrawer=new Ammo.DebugDrawer,this.debugDrawer.drawLine=this.drawLine.bind(this),this.debugDrawer.drawContactPoint=this.drawContactPoint.bind(this),this.debugDrawer.reportErrorWarning=this.reportErrorWarning.bind(this),this.debugDrawer.draw3dText=this.draw3dText.bind(this),this.debugDrawer.setDebugMode=this.setDebugMode.bind(this),this.debugDrawer.getDebugMode=this.getDebugMode.bind(this),this.world.setDebugDrawer(this.debugDrawer)}enable(){this.enabled=!0,this.scene.add(this.mesh)}disable(){this.enabled=!1,this.scene.remove(this.mesh)}update(){this.enabled&&(this.index!=0&&(this.geometry.attributes.position.needsUpdate=!0,this.geometry.attributes.color.needsUpdate=!0),this.index=0,this.world.debugDrawWorld(),this.geometry.setDrawRange(0,this.index))}drawLine(e,t,s){const n=Ammo.HEAPF32,i=n[(s+0)/4],r=n[(s+4)/4],a=n[(s+8)/4],o=n[(e+0)/4],c=n[(e+4)/4],h=n[(e+8)/4];this.geometry.attributes.position.setXYZ(this.index,o,c,h),this.geometry.attributes.color.setXYZ(this.index++,i,r,a);const l=n[(t+0)/4],d=n[(t+4)/4],p=n[(t+8)/4];this.geometry.attributes.position.setXYZ(this.index,l,d,p),this.geometry.attributes.color.setXYZ(this.index++,i,r,a)}drawContactPoint(e,t,s,n,i){const r=Ammo.HEAPF32,a=r[(i+0)/4],o=r[(i+4)/4],c=r[(i+8)/4],h=r[(e+0)/4],l=r[(e+4)/4],d=r[(e+8)/4];this.geometry.attributes.position.setXYZ(this.index,h,l,d),this.geometry.attributes.color.setXYZ(this.index++,a,o,c);const p=r[(t+0)/4]*s,w=r[(t+4)/4]*s,x=r[(t+8)/4]*s;this.geometry.attributes.position.setXYZ(this.index,h+p,l+w,d+x),this.geometry.attributes.color.setXYZ(this.index++,a,o,c)}reportErrorWarning(e){Ammo.hasOwnProperty("Pointer_stringify")?console.warn(Ammo.Pointer_stringify(e)):this.warnedOnce||(this.warnedOnce=!0,console.warn("Cannot print warningString, please rebuild Ammo.js using 'debug' flag"))}draw3dText(e,t){console.warn("TODO: draw3dText")}setDebugMode(e){this.debugDrawMode=e}getDebugMode(){return this.debugDrawMode}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
 */class Ei extends Ct{constructor(t,s={}){super();v(this,"scene");v(this,"config");v(this,"worldTransform");v(this,"factory");v(this,"isHeadless");v(this,"rigidBodies",[]);v(this,"earlierDetectedCollisions",[]);v(this,"gravity");v(this,"tmpEuler");v(this,"tmpQuaternion");v(this,"tmpVector3");v(this,"tmpVector3a");v(this,"tmpMatrix4");v(this,"tmpMatrix4a");v(this,"tmpBtVector3");v(this,"tmpBtQuaternion");v(this,"physicsWorld");v(this,"debugDrawer");v(this,"convexBreaker");v(this,"addRigidBody");v(this,"objectsToRemove");v(this,"numObjectsToRemove");v(this,"emptyV3");v(this,"impactPoint");v(this,"impactNormal");v(this,"defaultMaterial");v(this,"shapes");v(this,"constraints");v(this,"collisionEvents");v(this,"complexShapes",["plane","hull","hacd","vhacd","convexMesh","concaveMesh"]);this.scene=t,this.config=s,this.gravity=s.gravity||{x:0,y:-9.81,z:0},this.isHeadless=t==="headless",this.tmpEuler=new Ve,this.tmpQuaternion=new ge,this.tmpVector3=new G,this.tmpVector3a=new G,this.tmpMatrix4=new se,this.tmpMatrix4a=new se,this.tmpBtVector3=new Ammo.btVector3,this.tmpBtQuaternion=new Ammo.btQuaternion(0,0,0,1),this.emptyV3=new G,this.impactPoint=new G,this.impactNormal=new G,t!=="headless"&&(this.defaultMaterial=new Ys),this.start()}get tmpTrans(){return console.warn("Use worldTransform instead of tmpTrans."),this.worldTransform}set tmpTrans(t){console.warn("Use worldTransform instead of tmpTrans."),this.worldTransform=t}destroy(t){var r;const s=Object.keys(t).includes("body")?t.body:t;if(typeof(s==null?void 0:s.ammo)>"u")return;let n=s.ammo.threeObject;const i=n.name;if(i&&n&&(r=n==null?void 0:n.body)!=null&&r.ammo){n.body.isSoftBody?this.physicsWorld.removeSoftBody(n.body.ammo):this.physicsWorld.removeRigidBody(n.body.ammo),n.body.destructor(),n.body=void 0,n.hasBody=!1,delete s.ammo.threeObject;for(let a=0;a<this.rigidBodies.length;a++)this.rigidBodies[a].name===i&&(this.rigidBodies.splice(a,1),a--)}this.scene==="headless"&&n&&(n=null)}setup(){if(this.worldTransform=new Ammo.btTransform,typeof this.config.setupPhysicsWorld=="function"?this.physicsWorld=this.config.setupPhysicsWorld():this.physicsWorld=this.setupPhysicsWorld(),this.scene!=="headless"){this.convexBreaker=new En,this.objectsToRemove=[],this.numObjectsToRemove=0;for(let t=0;t<500;t++)this.objectsToRemove[t]=null}this.collisionEvents=new Mi,this.factory=new Qs(this.scene),this.shapes=new Ai(this.factory,(t,s)=>this.addExisting(t,s)),this.constraints=new Ti(this.worldTransform,this.physicsWorld),this.scene!=="headless"&&(this.debugDrawer=new Si(this.scene,this.physicsWorld,{}))}updateDebugger(){this.scene!=="headless"&&this.debugDrawer&&this.debugDrawer.enabled&&this.debugDrawer.update()}setupPhysicsWorld(){const t=this.gravity,{softBodies:s=!1}=this.config;let n;if(!s){const i=new Ammo.btDefaultCollisionConfiguration,r=new Ammo.btCollisionDispatcher(i),a=new Ammo.btDbvtBroadphase,o=new Ammo.btSequentialImpulseConstraintSolver;n=new Ammo.btDiscreteDynamicsWorld(r,a,o,i)}if(s){const i=new Ammo.btSoftBodyRigidBodyCollisionConfiguration,r=new Ammo.btCollisionDispatcher(i),a=new Ammo.btDbvtBroadphase,o=new Ammo.btSequentialImpulseConstraintSolver,c=new Ammo.btDefaultSoftBodySolver;n=new Ammo.btSoftRigidDynamicsWorld(r,a,o,i,c)}return n.setGravity(new Ammo.btVector3(t.x,t.y,t.z)),n}createDebrisFromBreakableObject(t,s){this.scene!=="headless"&&(t.material=s.material,t.shape="hull",t.fragmentDepth=s.fragmentDepth+1,t.name=`${s.name}__DEBRIS_${t.id}`,this.scene.add(t),this.addExisting(t,{autoCenter:!0}),t.body.fractureImpulse=s.body.fractureImpulse,t.body.breakable=!1,setTimeout(()=>{t.body.breakable=!0},2500))}removeDebris(t){this.scene!=="headless"&&(this.scene.remove(t),this.destroy(t))}update(t){this.updatePhysics(t),this.detectCollisions()}updatePhysics(t){const s=t/1e3;this.physicsWorld.stepSimulation(s,this.config.maxSubSteps||4,this.config.fixedTimeStep||1/60);for(let n=0;n<this.rigidBodies.length;n++){const i=this.rigidBodies[n];i.body.impact=[];const a=i.body.ammo.getMotionState();if(a){if(a.getWorldTransform(this.worldTransform),i.body.didUpdate&&(i.body._emitUpdateEvents&&i.body.eventEmitter.emit("update"),i.body.didUpdate=!1),i.body.ammo.isKinematicObject()&&i.body.needUpdate)i.getWorldQuaternion(this.tmpQuaternion),i.getWorldPosition(this.tmpVector3),this.tmpBtVector3.setValue(this.tmpVector3.x,this.tmpVector3.y,this.tmpVector3.z),this.tmpBtQuaternion.setValue(this.tmpQuaternion.x,this.tmpQuaternion.y,this.tmpQuaternion.z,this.tmpQuaternion.w),this.worldTransform.setOrigin(this.tmpBtVector3),this.worldTransform.setRotation(this.tmpBtQuaternion),a.setWorldTransform(this.worldTransform),i.body.needUpdate=!1;else if(!i.body.skipUpdate){if(!i.body.ammo.isStaticObject()){const o=this.worldTransform.getOrigin(),c=this.worldTransform.getRotation(),h=i.body.offset;if(i.body.ignoreScale)this.tmpVector3a.set(i.scale.x,i.scale.y,i.scale.z);else{const l=i.body.ammo.getCollisionShape().getLocalScaling();this.tmpVector3a.set(l.x(),l.y(),l.z())}this.tmpVector3.set(o.x()+h.x,o.y()+h.y,o.z()+h.z),this.tmpQuaternion.set(c.x(),c.y(),c.z(),c.w()),this.tmpMatrix4.compose(this.tmpVector3,this.tmpQuaternion,this.tmpVector3a),i.parent?parseInt(_n)>=123?this.tmpMatrix4a.copy(i.parent.matrixWorld).invert():this.tmpMatrix4a.getInverse(i.parent.matrixWorld):this.tmpMatrix4a.identity(),this.tmpMatrix4a.multiply(this.tmpMatrix4),this.tmpMatrix4a.decompose(i.position,i.quaternion,i.scale)}}}}}detectCollisions(){var i,r;const t=[];this.impactPoint.set(0,0,0),this.impactNormal.set(0,0,0);const s=this.physicsWorld.getDispatcher(),n=s.getNumManifolds();for(let a=0;a<n;a++){const o=s.getManifoldByIndexInternal(a),c=o.getNumContacts(),h=Ammo.castObject(o.getBody0(),Ammo.btRigidBody),l=Ammo.castObject(o.getBody1(),Ammo.btRigidBody),d=h.threeObject,p=l.threeObject;if(!d||!p||h.name===""&&l.name==="")continue;const w=(i=d.body)==null?void 0:i.checkCollisions,x=(r=p.body)==null?void 0:r.checkCollisions,y=d.body.breakable,T=p.body.breakable,_=d.body.fractureImpulse,b=p.body.fractureImpulse,S=w||x,P=y||T;if(typeof d.fragmentDepth>"u"&&(d.fragmentDepth=0),typeof p.fragmentDepth>"u"&&(p.fragmentDepth=0),!S&&!P)continue;let C=!1,D=0,k="start";for(let O=0;O<c;O++){const U=o.getContactPoint(O);if(U.getDistance()<=0){C=!0;const $=U.getAppliedImpulse(),Y=U.get_m_positionWorldOnB(),te=U.get_m_normalWorldOnB();if(w||x){const ie=[d.uuid,p.uuid].sort(),Q=`${ie[0]}__${ie[1]}`;if(this.earlierDetectedCollisions.find(F=>F.combinedName===Q)&&(k="collision"),!t.find(F=>F.combinedName===Q)){t.push({combinedName:Q,collision:!0});const F={x:Y.x(),y:Y.y(),z:Y.z()},re={x:te.x(),y:te.y(),z:te.z()};d.body.impact.push({impulse:$,point:F,normal:re,name:p.name}),p.body.impact.push({impulse:$,point:F,normal:re,name:d.name}),this.collisionEvents.emit("collision",{bodies:[d,p],event:k})}}$>=D&&(D=$,(y||T)&&(this.impactPoint.set(Y.x(),Y.y(),Y.z()),this.impactNormal.set(te.x(),te.y(),te.z())));break}}if(!C||!P)continue;const B=2;if(this.emptyV3.set(0,0,0),d.userData.ammoPhysicsData={mass:1,velocity:this.emptyV3,angularVelocity:this.emptyV3,breakable:y,physicsBody:h},p.userData.ammoPhysicsData={mass:1,velocity:this.emptyV3,angularVelocity:this.emptyV3,breakable:T,physicsBody:l},y&&D>_&&d.fragmentDepth<B){const O=this.convexBreaker.subdivideByImpact(d,this.impactPoint,this.impactNormal,1,2),U=O.length;for(let j=0;j<U;j++){const $=h.getLinearVelocity(),Y=h.getAngularVelocity(),te=O[j];te.userData.ammoPhysicsData.velocity.set($.x(),$.y(),$.z()),te.userData.ammoPhysicsData.angularVelocity.set(Y.x(),Y.y(),Y.z()),this.createDebrisFromBreakableObject(te,d)}this.objectsToRemove[this.numObjectsToRemove++]=d}if(T&&D>b&&p.fragmentDepth<B){const O=this.convexBreaker.subdivideByImpact(p,this.impactPoint,this.impactNormal,1,2),U=O.length;for(let j=0;j<U;j++){const $=l.getLinearVelocity(),Y=l.getAngularVelocity(),te=O[j];te.userData.ammoPhysicsData.velocity.set($.x(),$.y(),$.z()),te.userData.ammoPhysicsData.angularVelocity.set(Y.x(),Y.y(),Y.z()),this.createDebrisFromBreakableObject(te,p)}this.objectsToRemove[this.numObjectsToRemove++]=p}}for(let a=0;a<this.numObjectsToRemove;a++)this.removeDebris(this.objectsToRemove[a]);this.numObjectsToRemove=0,this.earlierDetectedCollisions.forEach(a=>{const{combinedName:o}=a;if(!t.find(c=>c.combinedName===o)){const c=o.split("__"),h=this.rigidBodies.find(p=>p.uuid===c[0]),l=this.rigidBodies.find(p=>p.uuid===c[1]);h&&l&&this.collisionEvents.emit("collision",{bodies:[h,l],event:"end"})}}),this.earlierDetectedCollisions=[...t]}setGravity(t=0,s=-9.8,n=0){this.tmpBtVector3.setValue(t,s,n),this.physicsWorld.setGravity(this.tmpBtVector3)}get debug(){return this.isHeadless?null:{enable:()=>{this.debugDrawer.enable()},mode:(t=1)=>{this.debugDrawer.setDebugMode(t)},disable:()=>{this.debugDrawer.disable()}}}start(){if(typeof Ammo>"u"){Fe("Are you sure you included ammo.js?");return}typeof Ammo=="function"?Ammo().then(()=>{this.setup()}):this.setup()}get add(){return{collider:(t,s,n)=>this.collisionEvents.addCollider(t,s,n),constraints:this.constraints.addConstraints,existing:(t,s)=>this.addExisting(t,s),plane:(t={},s={})=>this.shapes.addPlane(t,s),sphere:(t={},s={})=>this.shapes.addSphere(t,s),ground:(t={},s={})=>this.shapes.addGround(t,s),box:(t={},s={})=>this.shapes.addBox(t,s),capsule:(t={},s={})=>this.shapes.addCapsule(t,s),cylinder:(t={},s={})=>this.shapes.addCylinder(t,s),cone:(t={},s={})=>this.shapes.addCone(t,s),torus:(t={},s={})=>this.shapes.addTorus(t,s),extrude:(t,s={})=>this.shapes.addExtrude(t,s),raycaster:(t="closest")=>t==="closest"?new Pn(this):new Rn(this)}}prepareThreeObjectForCollisionShape(t,s={}){var c,h;const{autoCenter:n=!1}=s,i={width:1,height:1,depth:1,radius:1,radiusTop:1,radiusBottom:1,tube:.4,tubularSegments:6};let r="unknown";const a=t.isMesh?(c=t.geometry)==null?void 0:c.type:"unknown";/box/i.test(a)?r="box":/cone/i.test(a)?r="cone":/cylinder/i.test(a)?r="cylinder":/extrude/i.test(a)?r="extrude":/plane/i.test(a)?r="plane":/sphere/i.test(a)?r="sphere":/torus/i.test(a)&&(r="torus");let o={...i,...(h=t==null?void 0:t.geometry)==null?void 0:h.parameters};if(s.shape?(o={...i,...s},r=s.shape):t.shape&&(r=t.shape),Object.keys(o).forEach(l=>{typeof o[l]>"u"&&i[l]&&(o[l]=i[l])}),n){if(t.isMesh&&t.geometry)t.geometry.center();else if(t.isGroup){const l=new Ze,d=new G;l.setFromObject(t).getCenter(d),t.traverse(p=>{p.isMesh&&p.geometry.translate(-d.x,-d.y,-d.z)})}}return r==="cylinder"&&(o.radius=s.radius||o.radiusTop),r==="extrude"&&(r="hacd"),(r==="mesh"||r==="convex")&&(r="convexMesh"),r==="concave"&&(r="concaveMesh"),r==="unknown"&&(Fe(`Shape for ${t==null?void 0:t.name} not recognized! Will fallback to box.`),r="box"),{shape:r,params:o,object:t}}createCollisionShape(t,s,n){const i=n!=null&&n.quaternion?n==null?void 0:n.quaternion:new ge(0,0,0,1),{axis:r="y"}=s,a=new Ammo.btVector3,o=n==null?void 0:n.geometry;n&&(o!=null&&o.isGeometry)&&(n.geometry=new ze().fromGeometry(o));const c=x=>{const y=new se().elements,T=[],_=[],b=[];return kn(x,{},(S,P,C)=>{T.push(S),_.push(P),b.push(C)}),{vertices:T,matrices:_,indexes:b,matrixWorld:y}};let h={};this.complexShapes.indexOf(t)!==-1&&(h=c(n));let l;switch(t){case"box":a.setValue(s.width/2,s.height/2,s.depth/2),l=new Ammo.btBoxShape(a);break;case"sphere":l=new Ammo.btSphereShape(s.radius);break;case"cylinder":switch(r){case"y":a.setValue(s.radius,s.height/2,s.radius),l=new Ammo.btCylinderShape(a);break;case"x":a.setValue(s.height/2,s.radius,s.radius),l=new Ammo.btCylinderShapeX(a);break;case"z":a.setValue(s.radius,s.radius,s.height/2),l=new Ammo.btCylinderShapeZ(a);break}break;case"cone":switch(r){case"y":l=new Ammo.btConeShape(s.radius,s.height);break;case"x":l=new Ammo.btConeShapeX(s.radius,s.height);break;case"z":l=new Ammo.btConeShapeZ(s.radius,s.height);break}break;case"capsule":switch(r){case"y":l=new Ammo.btCapsuleShape(s.radius,s.height);break;case"x":l=new Ammo.btCapsuleShapeX(s.radius,s.height);break;case"z":l=new Ammo.btCapsuleShapeZ(s.radius,s.height);break}break;case"torus":l=vi(s,i);break;case"plane":l=Vt(h.vertices,h.matrices,h.indexes,h.matrixWorld,{...s,concave:!1});break;case"hull":l=In(h.vertices,h.matrices,h.matrixWorld,s);break;case"hacd":l=Ln(h.vertices,h.matrices,h.indexes,h.matrixWorld,s);break;case"vhacd":l=Cn(h.vertices,h.matrices,h.indexes,h.matrixWorld,s);break;case"convexMesh":l=Vt(h.vertices,h.matrices,h.indexes,h.matrixWorld,{...s,concave:!1});break;case"concaveMesh":l=Vt(h.vertices,h.matrices,h.indexes,h.matrixWorld,{...s,concave:!0});break}Ammo.destroy(a);const{x:d,y:p,z:w}=s;return(d||p||w)&&(l._compoundOffset={x:d||0,y:p||0,z:w||0}),Array.isArray(l)&&(l=this.mergeCollisionShapesToCompoundShape(l)),l}mergeCollisionShapesToCompoundShape(t){const s=new Ammo.btCompoundShape;return t.forEach(n=>{const{_childOffset:i,_compoundOffset:r}=n;if(i){const{pos:a,quat:o,scale:c,margin:h}=i,l=this.applyPosQuatScaleMargin(n,a,o,c,h);s.addChildShape(l,n)}else if(r){const a=new Ammo.btTransform;a.setIdentity(),a.setOrigin(new Ammo.btVector3(r.x,r.y,r.z)),s.addChildShape(a,n)}else{const a=new Ammo.btTransform;a.setIdentity(),s.addChildShape(a,n)}}),s}addExisting(t,s={}){const{hasBody:n}=t;if(n){Fe(`Object "${t.name}" already has a physical body!`);return}const i=new G,r=new ge,a=new G;t.getWorldPosition(i),t.getWorldQuaternion(r),t.getWorldScale(a);const o=(s.collisionFlags||0).toString(2).slice(-1)==="1",c=(s.collisionFlags||0).toString(2).slice(-2,-1)==="1",{shape:h="unknown",compound:l=[],mass:d=o||c?0:1,collisionFlags:p=0,collisionGroup:w=1,collisionMask:x=-1,offset:y=void 0,breakable:T=!1,addChildren:_=!0,margin:b=.01,ignoreScale:S=!1,fractureImpulse:P=1}=s;if(S&&a.set(1,1,1),l.length>=1){const O=l.map(Y=>this.createCollisionShape(Y.shape,Y)),U=this.mergeCollisionShapesToCompoundShape(O),j=this.applyPosQuatScaleMargin(U,i,r,a,b),$=this.collisionShapeToRigidBody(U,j,d,c);this.addRigidBodyToWorld(t,$,p,w,x,y),t.body.breakable=T,t.body.fractureImpulse=P,t.body.ignoreScale=S;return}const C=[];if(h!=="unknown"||t.isMesh){const O=this.prepareThreeObjectForCollisionShape(t,s),U=this.createCollisionShape(O.shape,O.params,O.object);C.push(U)}if(h==="unknown"&&_&&t.children.length>=1&&t.children.forEach(O=>{if(O.isMesh){const U=this.prepareThreeObjectForCollisionShape(O),j=this.createCollisionShape(U.shape,U.params,U.object);j._childOffset={pos:O.position.clone(),quat:O.quaternion.clone(),scale:O.scale.clone(),margin:b},C.push(j)}}),C.length===0){const O=this.prepareThreeObjectForCollisionShape(t,s),U=this.createCollisionShape(O.shape,O.params,O.object);C.push(U)}const D=C.length===1?C[0]:this.mergeCollisionShapesToCompoundShape(C),k=this.applyPosQuatScaleMargin(D,i,r,a,b),B=this.collisionShapeToRigidBody(D,k,d,c);this.addRigidBodyToWorld(t,B,p,w,x,y),t.body.breakable=T,t.body.fractureImpulse=P,t.body.ignoreScale=S}addRigidBodyToWorld(t,s,n,i,r,a){this.rigidBodies.push(t),this.physicsWorld.addRigidBody(s,i,r);const o=Object.values(s)[0];t.name||(t.name=`object-${t.id}`),s.name=t.name,t.body=new wi(this,s),t.hasBody=!0,t.ptr=o,s.threeObject=t,a&&(t.body.offset={x:0,y:0,z:0,...a}),t.body.setCollisionFlags(n)}applyPosQuatScaleMargin(t,s=new G,n=new ge,i=new G,r=.01){t.setMargin(r);const a=new Ammo.btQuaternion(0,0,0,1);a.setValue(n.x,n.y,n.z,n.w);const o=new Ammo.btTransform;o.setIdentity(),o.getOrigin().setValue(s.x,s.y,s.z),o.setRotation(a),Ammo.destroy(a);const c=new Ammo.btVector3(i.x,i.y,i.z);return t.setLocalScaling(c),Ammo.destroy(c),o}collisionShapeToRigidBody(t,s,n,i){const r=new Ammo.btDefaultMotionState(s),a=new Ammo.btVector3(0,0,0);n>0&&t.calculateLocalInertia(n,a);const o=new Ammo.btRigidBodyConstructionInfo(n,r,t,a),c=new Ammo.btRigidBody(o);return(n>0||i)&&c.setActivationState(4),c}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
 */class _i{constructor(e={}){v(this,"threeGraphicsConfig");v(this,"cache");v(this,"scene");v(this,"renderer");v(this,"camera");v(this,"textureAnisotropy");v(this,"cameras");v(this,"physics");this.threeGraphicsConfig=e;const{alpha:t=!1,anisotropy:s=1,camera:n=dt.Perspective({z:25,y:5}),antialias:i=!1,usePhysics:r=!0,renderer:a}=e;this.textureAnisotropy=s,this.camera=n,this.scene=new Dn,this.renderer=a||new Fs({antialias:i,alpha:t}),this.renderer.shadowMap.enabled=!0,this.renderer.shadowMap.type=On,this.cache=Fn,this.cache.enabled=!0,r&&(typeof Ammo<"u"?this.physics=new Ei(this.scene,e):Fe("Are you sure you included ammo.js?"))}}/*!
fflate - fast JavaScript compression/decompression
<https://101arrowz.github.io/fflate>
Licensed under MIT. https://github.com/101arrowz/fflate/blob/master/LICENSE
version 0.8.2
*/var Me=Uint8Array,et=Uint16Array,Pi=Int32Array,Zs=new Me([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),$s=new Me([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Ri=new Me([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Js=function(u,e){for(var t=new et(31),s=0;s<31;++s)t[s]=e+=1<<u[s-1];for(var n=new Pi(t[30]),s=1;s<30;++s)for(var i=t[s];i<t[s+1];++i)n[i]=i-t[s]<<5|s;return{b:t,r:n}},en=Js(Zs,2),tn=en.b,Ci=en.r;tn[28]=258,Ci[258]=28;var Li=Js($s,0),Ii=Li.b,is=new et(32768);for(var ce=0;ce<32768;++ce){var We=(ce&43690)>>1|(ce&21845)<<1;We=(We&52428)>>2|(We&13107)<<2,We=(We&61680)>>4|(We&3855)<<4,is[ce]=((We&65280)>>8|(We&255)<<8)>>1}var ct=function(u,e,t){for(var s=u.length,n=0,i=new et(e);n<s;++n)u[n]&&++i[u[n]-1];var r=new et(e);for(n=1;n<e;++n)r[n]=r[n-1]+i[n-1]<<1;var a;if(t){a=new et(1<<e);var o=15-e;for(n=0;n<s;++n)if(u[n])for(var c=n<<4|u[n],h=e-u[n],l=r[u[n]-1]++<<h,d=l|(1<<h)-1;l<=d;++l)a[is[l]>>o]=c}else for(a=new et(s),n=0;n<s;++n)u[n]&&(a[n]=is[r[u[n]-1]++]>>15-u[n]);return a},bt=new Me(288);for(var ce=0;ce<144;++ce)bt[ce]=8;for(var ce=144;ce<256;++ce)bt[ce]=9;for(var ce=256;ce<280;++ce)bt[ce]=7;for(var ce=280;ce<288;++ce)bt[ce]=8;var sn=new Me(32);for(var ce=0;ce<32;++ce)sn[ce]=5;var ki=ct(bt,9,1),Di=ct(sn,5,1),jt=function(u){for(var e=u[0],t=1;t<u.length;++t)u[t]>e&&(e=u[t]);return e},Ee=function(u,e,t){var s=e/8|0;return(u[s]|u[s+1]<<8)>>(e&7)&t},Gt=function(u,e){var t=e/8|0;return(u[t]|u[t+1]<<8|u[t+2]<<16)>>(e&7)},Oi=function(u){return(u+7)/8|0},Fi=function(u,e,t){return(t==null||t>u.length)&&(t=u.length),new Me(u.subarray(e,t))},Ni=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],_e=function(u,e,t){var s=new Error(e||Ni[u]);if(s.code=u,Error.captureStackTrace&&Error.captureStackTrace(s,_e),!t)throw s;return s},Bi=function(u,e,t,s){var n=u.length,i=0;if(!n||e.f&&!e.l)return t||new Me(0);var r=!t,a=r||e.i!=2,o=e.i;r&&(t=new Me(n*3));var c=function(z){var H=t.length;if(z>H){var W=new Me(Math.max(H*2,z));W.set(t),t=W}},h=e.f||0,l=e.p||0,d=e.b||0,p=e.l,w=e.d,x=e.m,y=e.n,T=n*8;do{if(!p){h=Ee(u,l,1);var _=Ee(u,l+1,3);if(l+=3,_)if(_==1)p=ki,w=Di,x=9,y=5;else if(_==2){var C=Ee(u,l,31)+257,D=Ee(u,l+10,15)+4,k=C+Ee(u,l+5,31)+1;l+=14;for(var B=new Me(k),O=new Me(19),U=0;U<D;++U)O[Ri[U]]=Ee(u,l+U*3,7);l+=D*3;for(var j=jt(O),$=(1<<j)-1,Y=ct(O,j,1),U=0;U<k;){var te=Y[Ee(u,l,$)];l+=te&15;var b=te>>4;if(b<16)B[U++]=b;else{var ie=0,Q=0;for(b==16?(Q=3+Ee(u,l,3),l+=2,ie=B[U-1]):b==17?(Q=3+Ee(u,l,7),l+=3):b==18&&(Q=11+Ee(u,l,127),l+=7);Q--;)B[U++]=ie}}var F=B.subarray(0,C),re=B.subarray(C);x=jt(F),y=jt(re),p=ct(F,x,1),w=ct(re,y,1)}else _e(1);else{var b=Oi(l)+4,S=u[b-4]|u[b-3]<<8,P=b+S;if(P>n){o&&_e(0);break}a&&c(d+S),t.set(u.subarray(b,P),d),e.b=d+=S,e.p=l=P*8,e.f=h;continue}if(l>T){o&&_e(0);break}}a&&c(d+131072);for(var le=(1<<x)-1,be=(1<<y)-1,Se=l;;Se=l){var ie=p[Gt(u,l)&le],Ce=ie>>4;if(l+=ie&15,l>T){o&&_e(0);break}if(ie||_e(2),Ce<256)t[d++]=Ce;else if(Ce==256){Se=l,p=null;break}else{var E=Ce-254;if(Ce>264){var U=Ce-257,A=Zs[U];E=Ee(u,l,(1<<A)-1)+tn[U],l+=A}var m=w[Gt(u,l)&be],f=m>>4;m||_e(3),l+=m&15;var re=Ii[f];if(f>3){var A=$s[f];re+=Gt(u,l)&(1<<A)-1,l+=A}if(l>T){o&&_e(0);break}a&&c(d+131072);var L=d+E;if(d<re){var V=i-re,R=Math.min(re,L);for(V+d<0&&_e(3);d<R;++d)t[d]=s[V+d]}for(;d<L;++d)t[d]=t[d-re]}}e.l=p,e.p=Se,e.b=d,e.f=h,p&&(h=1,e.m=x,e.d=w,e.n=y)}while(!h);return d!=t.length&&r?Fi(t,0,d):t.subarray(0,d)},Vi=new Me(0),Ui=function(u,e){return((u[0]&15)!=8||u[0]>>4>7||(u[0]<<8|u[1])%31)&&_e(6,"invalid zlib data"),(u[1]>>5&1)==1&&_e(6,"invalid zlib data: "+(u[1]&32?"need":"unexpected")+" dictionary"),(u[1]>>3&4)+2};function zi(u,e){return Bi(u.subarray(Ui(u),-4),{i:2},e,e)}var ji=typeof TextDecoder<"u"&&new TextDecoder,Gi=0;try{ji.decode(Vi,{stream:!0}),Gi=1}catch{}function nn(u,e,t){const s=t.length-u-1;if(e>=t[s])return s-1;if(e<=t[u])return u;let n=u,i=s,r=Math.floor((n+i)/2);for(;e<t[r]||e>=t[r+1];)e<t[r]?i=r:n=r,r=Math.floor((n+i)/2);return r}function Hi(u,e,t,s){const n=[],i=[],r=[];n[0]=1;for(let a=1;a<=t;++a){i[a]=e-s[u+1-a],r[a]=s[u+a]-e;let o=0;for(let c=0;c<a;++c){const h=r[c+1],l=i[a-c],d=n[c]/(h+l);n[c]=o+h*d,o=l*d}n[a]=o}return n}function Wi(u,e,t,s){const n=nn(u,s,e),i=Hi(n,s,u,e),r=new Ne(0,0,0,0);for(let a=0;a<=u;++a){const o=t[n-u+a],c=i[a],h=o.w*c;r.x+=o.x*h,r.y+=o.y*h,r.z+=o.z*h,r.w+=o.w*c}return r}function Xi(u,e,t,s,n){const i=[];for(let l=0;l<=t;++l)i[l]=0;const r=[];for(let l=0;l<=s;++l)r[l]=i.slice(0);const a=[];for(let l=0;l<=t;++l)a[l]=i.slice(0);a[0][0]=1;const o=i.slice(0),c=i.slice(0);for(let l=1;l<=t;++l){o[l]=e-n[u+1-l],c[l]=n[u+l]-e;let d=0;for(let p=0;p<l;++p){const w=c[p+1],x=o[l-p];a[l][p]=w+x;const y=a[p][l-1]/a[l][p];a[p][l]=d+w*y,d=x*y}a[l][l]=d}for(let l=0;l<=t;++l)r[0][l]=a[l][t];for(let l=0;l<=t;++l){let d=0,p=1;const w=[];for(let x=0;x<=t;++x)w[x]=i.slice(0);w[0][0]=1;for(let x=1;x<=s;++x){let y=0;const T=l-x,_=t-x;l>=x&&(w[p][0]=w[d][0]/a[_+1][T],y=w[p][0]*a[T][_]);const b=T>=-1?1:-T,S=l-1<=_?x-1:t-l;for(let C=b;C<=S;++C)w[p][C]=(w[d][C]-w[d][C-1])/a[_+1][T+C],y+=w[p][C]*a[T+C][_];l<=_&&(w[p][x]=-w[d][x-1]/a[_+1][l],y+=w[p][x]*a[l][_]),r[x][l]=y;const P=d;d=p,p=P}}let h=t;for(let l=1;l<=s;++l){for(let d=0;d<=t;++d)r[l][d]*=h;h*=t-l}return r}function Ki(u,e,t,s,n){const i=n<u?n:u,r=[],a=nn(u,s,e),o=Xi(a,s,u,i,e),c=[];for(let h=0;h<t.length;++h){const l=t[h].clone(),d=l.w;l.x*=d,l.y*=d,l.z*=d,c[h]=l}for(let h=0;h<=i;++h){const l=c[a-u].clone().multiplyScalar(o[h][0]);for(let d=1;d<=u;++d)l.add(c[a-u+d].clone().multiplyScalar(o[h][d]));r[h]=l}for(let h=i+1;h<=n+1;++h)r[h]=new Ne(0,0,0);return r}function qi(u,e){let t=1;for(let n=2;n<=u;++n)t*=n;let s=1;for(let n=2;n<=e;++n)s*=n;for(let n=2;n<=u-e;++n)s*=n;return t/s}function Yi(u){const e=u.length,t=[],s=[];for(let i=0;i<e;++i){const r=u[i];t[i]=new G(r.x,r.y,r.z),s[i]=r.w}const n=[];for(let i=0;i<e;++i){const r=t[i].clone();for(let a=1;a<=i;++a)r.sub(n[i-a].clone().multiplyScalar(qi(i,a)*s[a]));n[i]=r.divideScalar(s[0])}return n}function Qi(u,e,t,s,n){const i=Ki(u,e,t,s,n);return Yi(i)}class Zi extends Nn{constructor(e,t,s,n,i){super();const r=t?t.length-1:0,a=s?s.length:0;this.degree=e,this.knots=t,this.controlPoints=[],this.startKnot=n||0,this.endKnot=i||r;for(let o=0;o<a;++o){const c=s[o];this.controlPoints[o]=new Ne(c.x,c.y,c.z,c.w)}}getPoint(e,t=new G){const s=t,n=this.knots[this.startKnot]+e*(this.knots[this.endKnot]-this.knots[this.startKnot]),i=Wi(this.degree,this.knots,this.controlPoints,n);return i.w!==1&&i.divideScalar(i.w),s.set(i.x,i.y,i.z)}getTangent(e,t=new G){const s=t,n=this.knots[0]+e*(this.knots[this.knots.length-1]-this.knots[0]),i=Qi(this.degree,this.knots,this.controlPoints,n,1);return s.copy(i[1]).normalize(),s}toJSON(){const e=super.toJSON();return e.degree=this.degree,e.knots=[...this.knots],e.controlPoints=this.controlPoints.map(t=>t.toArray()),e.startKnot=this.startKnot,e.endKnot=this.endKnot,e}fromJSON(e){return super.fromJSON(e),this.degree=e.degree,this.knots=[...e.knots],this.controlPoints=e.controlPoints.map(t=>new Ne(t[0],t[1],t[2],t[3])),this.startKnot=e.startKnot,this.endKnot=e.endKnot,this}}let J,de,xe;class $i extends ht{constructor(e){super(e)}load(e,t,s,n){const i=this,r=i.path===""?tt.extractUrlBase(e):i.path,a=new wt(this.manager);a.setPath(i.path),a.setResponseType("arraybuffer"),a.setRequestHeader(i.requestHeader),a.setWithCredentials(i.withCredentials),a.load(e,function(o){try{t(i.parse(o,r))}catch(c){n?n(c):console.error(c),i.manager.itemError(e)}},s,n)}parse(e,t){if(ir(e))J=new nr().parse(e);else{const n=an(e);if(!rr(n))throw new Error("THREE.FBXLoader: Unknown format.");if(Ts(n)<7e3)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+Ts(n));J=new sr().parse(n)}const s=new Ot(this.manager).setPath(this.resourcePath||t).setCrossOrigin(this.crossOrigin);return new Ji(s,this.manager).parse(J)}}class Ji{constructor(e,t){this.textureLoader=e,this.manager=t}parse(){de=this.parseConnections();const e=this.parseImages(),t=this.parseTextures(e),s=this.parseMaterials(t),n=this.parseDeformers(),i=new er().parse(n);return this.parseScene(n,i,s),xe}parseConnections(){const e=new Map;return"Connections"in J&&J.Connections.connections.forEach(function(s){const n=s[0],i=s[1],r=s[2];e.has(n)||e.set(n,{parents:[],children:[]});const a={ID:i,relationship:r};e.get(n).parents.push(a),e.has(i)||e.set(i,{parents:[],children:[]});const o={ID:n,relationship:r};e.get(i).children.push(o)}),e}parseImages(){const e={},t={};if("Video"in J.Objects){const s=J.Objects.Video;for(const n in s){const i=s[n],r=parseInt(n);if(e[r]=i.RelativeFilename||i.Filename,"Content"in i){const a=i.Content instanceof ArrayBuffer&&i.Content.byteLength>0,o=typeof i.Content=="string"&&i.Content!=="";if(a||o){const c=this.parseImage(s[n]);t[i.RelativeFilename||i.Filename]=c}}}}for(const s in e){const n=e[s];t[n]!==void 0?e[s]=t[n]:e[s]=e[s].split("\\").pop()}return e}parseImage(e){const t=e.Content,s=e.RelativeFilename||e.Filename,n=s.slice(s.lastIndexOf(".")+1).toLowerCase();let i;switch(n){case"bmp":i="image/bmp";break;case"jpg":case"jpeg":i="image/jpeg";break;case"png":i="image/png";break;case"tif":i="image/tiff";break;case"tga":this.manager.getHandler(".tga")===null&&console.warn("FBXLoader: TGA loader not found, skipping ",s),i="image/tga";break;default:console.warn('FBXLoader: Image type "'+n+'" is not supported.');return}if(typeof t=="string")return"data:"+i+";base64,"+t;{const r=new Uint8Array(t);return window.URL.createObjectURL(new Blob([r],{type:i}))}}parseTextures(e){const t=new Map;if("Texture"in J.Objects){const s=J.Objects.Texture;for(const n in s){const i=this.parseTexture(s[n],e);t.set(parseInt(n),i)}}return t}parseTexture(e,t){const s=this.loadTexture(e,t);s.ID=e.id,s.name=e.attrName;const n=e.WrapModeU,i=e.WrapModeV,r=n!==void 0?n.value:0,a=i!==void 0?i.value:0;if(s.wrapS=r===0?je:Zt,s.wrapT=a===0?je:Zt,"Scaling"in e){const o=e.Scaling.value;s.repeat.x=o[0],s.repeat.y=o[1]}if("Translation"in e){const o=e.Translation.value;s.offset.x=o[0],s.offset.y=o[1]}return s}loadTexture(e,t){const s=new Set(["tga","tif","tiff","exr","dds","hdr","ktx2"]),n=e.FileName.split(".").pop().toLowerCase(),i=s.has(n)?this.manager.getHandler(`.${n}`):this.textureLoader;if(!i)return console.warn(`FBXLoader: ${n.toUpperCase()} loader not found, creating placeholder texture for`,e.RelativeFilename),new $t;const r=i.path;r||i.setPath(this.textureLoader.path);const a=de.get(e.id).children;let o;a!==void 0&&a.length>0&&t[a[0].ID]!==void 0&&(o=t[a[0].ID],(o.indexOf("blob:")===0||o.indexOf("data:")===0)&&i.setPath(void 0));const c=i.load(o);return i.setPath(r),c}parseMaterials(e){const t=new Map;if("Material"in J.Objects){const s=J.Objects.Material;for(const n in s){const i=this.parseMaterial(s[n],e);i!==null&&t.set(parseInt(n),i)}}return t}parseMaterial(e,t){const s=e.id,n=e.attrName;let i=e.ShadingModel;if(typeof i=="object"&&(i=i.value),!de.has(s))return null;const r=this.parseParameters(e,t,s);let a;switch(i.toLowerCase()){case"phong":a=new at;break;case"lambert":a=new as;break;default:console.warn('THREE.FBXLoader: unknown material type "%s". Defaulting to MeshPhongMaterial.',i),a=new at;break}return a.setValues(r),a.name=n,a}parseParameters(e,t,s){const n={};e.BumpFactor&&(n.bumpScale=e.BumpFactor.value),e.Diffuse?n.color=Ie.toWorkingColorSpace(new oe().fromArray(e.Diffuse.value),fe):e.DiffuseColor&&(e.DiffuseColor.type==="Color"||e.DiffuseColor.type==="ColorRGB")&&(n.color=Ie.toWorkingColorSpace(new oe().fromArray(e.DiffuseColor.value),fe)),e.DisplacementFactor&&(n.displacementScale=e.DisplacementFactor.value),e.Emissive?n.emissive=Ie.toWorkingColorSpace(new oe().fromArray(e.Emissive.value),fe):e.EmissiveColor&&(e.EmissiveColor.type==="Color"||e.EmissiveColor.type==="ColorRGB")&&(n.emissive=Ie.toWorkingColorSpace(new oe().fromArray(e.EmissiveColor.value),fe)),e.EmissiveFactor&&(n.emissiveIntensity=parseFloat(e.EmissiveFactor.value)),n.opacity=1-(e.TransparencyFactor?parseFloat(e.TransparencyFactor.value):0),(n.opacity===1||n.opacity===0)&&(n.opacity=e.Opacity?parseFloat(e.Opacity.value):null,n.opacity===null&&(n.opacity=1-(e.TransparentColor?parseFloat(e.TransparentColor.value[0]):0))),n.opacity<1&&(n.transparent=!0),e.ReflectionFactor&&(n.reflectivity=e.ReflectionFactor.value),e.Shininess&&(n.shininess=e.Shininess.value),e.Specular?n.specular=Ie.toWorkingColorSpace(new oe().fromArray(e.Specular.value),fe):e.SpecularColor&&e.SpecularColor.type==="Color"&&(n.specular=Ie.toWorkingColorSpace(new oe().fromArray(e.SpecularColor.value),fe));const i=this;return de.get(s).children.forEach(function(r){const a=r.relationship;switch(a){case"Bump":n.bumpMap=i.getTexture(t,r.ID);break;case"Maya|TEX_ao_map":n.aoMap=i.getTexture(t,r.ID);break;case"DiffuseColor":case"Maya|TEX_color_map":n.map=i.getTexture(t,r.ID),n.map!==void 0&&(n.map.colorSpace=fe);break;case"DisplacementColor":n.displacementMap=i.getTexture(t,r.ID);break;case"EmissiveColor":n.emissiveMap=i.getTexture(t,r.ID),n.emissiveMap!==void 0&&(n.emissiveMap.colorSpace=fe);break;case"NormalMap":case"Maya|TEX_normal_map":n.normalMap=i.getTexture(t,r.ID);break;case"ReflectionColor":n.envMap=i.getTexture(t,r.ID),n.envMap!==void 0&&(n.envMap.mapping=Bn,n.envMap.colorSpace=fe);break;case"SpecularColor":n.specularMap=i.getTexture(t,r.ID),n.specularMap!==void 0&&(n.specularMap.colorSpace=fe);break;case"TransparentColor":case"TransparencyFactor":n.alphaMap=i.getTexture(t,r.ID),n.transparent=!0;break;case"AmbientColor":case"ShininessExponent":case"SpecularFactor":case"VectorDisplacementColor":default:console.warn("THREE.FBXLoader: %s map is not supported in three.js, skipping texture.",a);break}}),n}getTexture(e,t){return"LayeredTexture"in J.Objects&&t in J.Objects.LayeredTexture&&(console.warn("THREE.FBXLoader: layered textures are not supported in three.js. Discarding all but first layer."),t=de.get(t).children[0].ID),e.get(t)}parseDeformers(){const e={},t={};if("Deformer"in J.Objects){const s=J.Objects.Deformer;for(const n in s){const i=s[n],r=de.get(parseInt(n));if(i.attrType==="Skin"){const a=this.parseSkeleton(r,s);a.ID=n,r.parents.length>1&&console.warn("THREE.FBXLoader: skeleton attached to more than one geometry is not supported."),a.geometryID=r.parents[0].ID,e[n]=a}else if(i.attrType==="BlendShape"){const a={id:n};a.rawTargets=this.parseMorphTargets(r,s),a.id=n,r.parents.length>1&&console.warn("THREE.FBXLoader: morph target attached to more than one geometry is not supported."),t[n]=a}}}return{skeletons:e,morphTargets:t}}parseSkeleton(e,t){const s=[];return e.children.forEach(function(n){const i=t[n.ID];if(i.attrType!=="Cluster")return;const r={ID:n.ID,indices:[],weights:[],transformLink:new se().fromArray(i.TransformLink.a)};"Indexes"in i&&(r.indices=i.Indexes.a,r.weights=i.Weights.a),s.push(r)}),{rawBones:s,bones:[]}}parseMorphTargets(e,t){const s=[];for(let n=0;n<e.children.length;n++){const i=e.children[n],r=t[i.ID],a={name:r.attrName,initialWeight:r.DeformPercent,id:r.id,fullWeights:r.FullWeights.a};if(r.attrType!=="BlendShapeChannel")return;a.geoID=de.get(parseInt(i.ID)).children.filter(function(o){return o.relationship===void 0})[0].ID,s.push(a)}return s}parseScene(e,t,s){xe=new st;const n=this.parseModels(e.skeletons,t,s),i=J.Objects.Model,r=this;n.forEach(function(o){const c=i[o.ID];r.setLookAtProperties(o,c),de.get(o.ID).parents.forEach(function(l){const d=n.get(l.ID);d!==void 0&&d.add(o)}),o.parent===null&&xe.add(o)}),this.bindSkeleton(e.skeletons,t,n),this.addGlobalSceneSettings(),xe.traverse(function(o){if(o.userData.transformData){o.parent&&(o.userData.transformData.parentMatrix=o.parent.matrix,o.userData.transformData.parentMatrixWorld=o.parent.matrixWorld);const c=on(o.userData.transformData);o.applyMatrix4(c),o.updateWorldMatrix()}});const a=new tr().parse();xe.children.length===1&&xe.children[0].isGroup&&(xe.children[0].animations=a,xe=xe.children[0]),xe.animations=a}parseModels(e,t,s){const n=new Map,i=J.Objects.Model;for(const r in i){const a=parseInt(r),o=i[r],c=de.get(a);let h=this.buildSkeleton(c,e,a,o.attrName);if(!h){switch(o.attrType){case"Camera":h=this.createCamera(c);break;case"Light":h=this.createLight(c);break;case"Mesh":h=this.createMesh(c,t,s);break;case"NurbsCurve":h=this.createCurve(c,t);break;case"LimbNode":case"Root":h=new Jt;break;case"Null":default:h=new st;break}h.name=o.attrName?ut.sanitizeNodeName(o.attrName):"",h.userData.originalName=o.attrName,h.ID=a}this.getTransformData(h,o),n.set(a,h)}return n}buildSkeleton(e,t,s,n){let i=null;return e.parents.forEach(function(r){for(const a in t){const o=t[a];o.rawBones.forEach(function(c,h){if(c.ID===r.ID){const l=i;i=new Jt,i.matrixWorld.copy(c.transformLink),i.name=n?ut.sanitizeNodeName(n):"",i.userData.originalName=n,i.ID=s,o.bones[h]=i,l!==null&&i.add(l)}})}}),i}createCamera(e){let t,s;if(e.children.forEach(function(n){const i=J.Objects.NodeAttribute[n.ID];i!==void 0&&(s=i)}),s===void 0)t=new Ue;else{let n=0;s.CameraProjectionType!==void 0&&s.CameraProjectionType.value===1&&(n=1);let i=1;s.NearPlane!==void 0&&(i=s.NearPlane.value/1e3);let r=1e3;s.FarPlane!==void 0&&(r=s.FarPlane.value/1e3);let a=window.innerWidth,o=window.innerHeight;s.AspectWidth!==void 0&&s.AspectHeight!==void 0&&(a=s.AspectWidth.value,o=s.AspectHeight.value);const c=a/o;let h=45;s.FieldOfView!==void 0&&(h=s.FieldOfView.value);const l=s.FocalLength?s.FocalLength.value:null;switch(n){case 0:t=new yt(h,c,i,r),l!==null&&t.setFocalLength(l);break;case 1:console.warn("THREE.FBXLoader: Orthographic cameras not supported yet."),t=new Ue;break;default:console.warn("THREE.FBXLoader: Unknown camera type "+n+"."),t=new Ue;break}}return t}createLight(e){let t,s;if(e.children.forEach(function(n){const i=J.Objects.NodeAttribute[n.ID];i!==void 0&&(s=i)}),s===void 0)t=new Ue;else{let n;s.LightType===void 0?n=0:n=s.LightType.value;let i=16777215;s.Color!==void 0&&(i=Ie.toWorkingColorSpace(new oe().fromArray(s.Color.value),fe));let r=s.Intensity===void 0?1:s.Intensity.value/100;s.CastLightOnObject!==void 0&&s.CastLightOnObject.value===0&&(r=0);let a=0;s.FarAttenuationEnd!==void 0&&(s.EnableFarAttenuation!==void 0&&s.EnableFarAttenuation.value===0?a=0:a=s.FarAttenuationEnd.value);const o=1;switch(n){case 0:t=new _t(i,r,a,o);break;case 1:t=new hs(i,r);break;case 2:let c=Math.PI/3;s.InnerAngle!==void 0&&(c=me.degToRad(s.InnerAngle.value));let h=0;s.OuterAngle!==void 0&&(h=me.degToRad(s.OuterAngle.value),h=Math.max(h,1)),t=new ls(i,r,a,c,h,o);break;default:console.warn("THREE.FBXLoader: Unknown light type "+s.LightType.value+", defaulting to a PointLight."),t=new _t(i,r);break}s.CastShadows!==void 0&&s.CastShadows.value===1&&(t.castShadow=!0)}return t}createMesh(e,t,s){let n,i=null,r=null;const a=[];return e.children.forEach(function(o){t.has(o.ID)&&(i=t.get(o.ID)),s.has(o.ID)&&a.push(s.get(o.ID))}),a.length>1?r=a:a.length>0?r=a[0]:(r=new at({name:ht.DEFAULT_MATERIAL_NAME,color:13421772}),a.push(r)),"color"in i.attributes&&a.forEach(function(o){o.vertexColors=!0}),i.FBX_Deformer?(n=new Ns(i,r),n.normalizeSkinWeights()):n=new Ae(i,r),n}createCurve(e,t){const s=e.children.reduce(function(i,r){return t.has(r.ID)&&(i=t.get(r.ID)),i},null),n=new xt({name:ht.DEFAULT_MATERIAL_NAME,color:3342591,linewidth:1});return new It(s,n)}getTransformData(e,t){const s={};"InheritType"in t&&(s.inheritType=parseInt(t.InheritType.value)),"RotationOrder"in t?s.eulerOrder=pt(t.RotationOrder.value):s.eulerOrder=pt(0),"Lcl_Translation"in t&&(s.translation=t.Lcl_Translation.value),"PreRotation"in t&&(s.preRotation=t.PreRotation.value),"Lcl_Rotation"in t&&(s.rotation=t.Lcl_Rotation.value),"PostRotation"in t&&(s.postRotation=t.PostRotation.value),"Lcl_Scaling"in t&&(s.scale=t.Lcl_Scaling.value),"ScalingOffset"in t&&(s.scalingOffset=t.ScalingOffset.value),"ScalingPivot"in t&&(s.scalingPivot=t.ScalingPivot.value),"RotationOffset"in t&&(s.rotationOffset=t.RotationOffset.value),"RotationPivot"in t&&(s.rotationPivot=t.RotationPivot.value),e.userData.transformData=s}setLookAtProperties(e,t){"LookAtProperty"in t&&de.get(e.ID).children.forEach(function(n){if(n.relationship==="LookAtProperty"){const i=J.Objects.Model[n.ID];if("Lcl_Translation"in i){const r=i.Lcl_Translation.value;e.target!==void 0?(e.target.position.fromArray(r),xe.add(e.target)):e.lookAt(new G().fromArray(r))}}})}bindSkeleton(e,t,s){const n=this.parsePoseNodes();for(const i in e){const r=e[i];de.get(parseInt(r.ID)).parents.forEach(function(o){if(t.has(o.ID)){const c=o.ID;de.get(c).parents.forEach(function(l){s.has(l.ID)&&s.get(l.ID).bind(new Bs(r.bones),n[l.ID])})}})}}parsePoseNodes(){const e={};if("Pose"in J.Objects){const t=J.Objects.Pose;for(const s in t)if(t[s].attrType==="BindPose"&&t[s].NbPoseNodes>0){const n=t[s].PoseNode;Array.isArray(n)?n.forEach(function(i){e[i.Node]=new se().fromArray(i.Matrix.a)}):e[n.Node]=new se().fromArray(n.Matrix.a)}}return e}addGlobalSceneSettings(){if("GlobalSettings"in J){if("AmbientColor"in J.GlobalSettings){const e=J.GlobalSettings.AmbientColor.value,t=e[0],s=e[1],n=e[2];if(t!==0||s!==0||n!==0){const i=new oe().setRGB(t,s,n,fe);xe.add(new Vs(i,1))}}"UnitScaleFactor"in J.GlobalSettings&&(xe.userData.unitScaleFactor=J.GlobalSettings.UnitScaleFactor.value)}}}class er{constructor(){this.negativeMaterialIndices=!1}parse(e){const t=new Map;if("Geometry"in J.Objects){const s=J.Objects.Geometry;for(const n in s){const i=de.get(parseInt(n)),r=this.parseGeometry(i,s[n],e);t.set(parseInt(n),r)}}return this.negativeMaterialIndices===!0&&console.warn("THREE.FBXLoader: The FBX file contains invalid (negative) material indices. The asset might not render as expected."),t}parseGeometry(e,t,s){switch(t.attrType){case"Mesh":return this.parseMeshGeometry(e,t,s);case"NurbsCurve":return this.parseNurbsGeometry(t)}}parseMeshGeometry(e,t,s){const n=s.skeletons,i=[],r=e.parents.map(function(l){return J.Objects.Model[l.ID]});if(r.length===0)return;const a=e.children.reduce(function(l,d){return n[d.ID]!==void 0&&(l=n[d.ID]),l},null);e.children.forEach(function(l){s.morphTargets[l.ID]!==void 0&&i.push(s.morphTargets[l.ID])});const o=r[0],c={};"RotationOrder"in o&&(c.eulerOrder=pt(o.RotationOrder.value)),"InheritType"in o&&(c.inheritType=parseInt(o.InheritType.value)),"GeometricTranslation"in o&&(c.translation=o.GeometricTranslation.value),"GeometricRotation"in o&&(c.rotation=o.GeometricRotation.value),"GeometricScaling"in o&&(c.scale=o.GeometricScaling.value);const h=on(c);return this.genGeometry(t,a,i,h)}genGeometry(e,t,s,n){const i=new ze;e.attrName&&(i.name=e.attrName);const r=this.parseGeoNode(e,t),a=this.genBuffers(r),o=new Pe(a.vertex,3);if(o.applyMatrix4(n),i.setAttribute("position",o),a.colors.length>0&&i.setAttribute("color",new Pe(a.colors,3)),t&&(i.setAttribute("skinIndex",new Vn(a.weightsIndices,4)),i.setAttribute("skinWeight",new Pe(a.vertexWeights,4)),i.FBX_Deformer=t),a.normal.length>0){const c=new Ke().getNormalMatrix(n),h=new Pe(a.normal,3);h.applyNormalMatrix(c),i.setAttribute("normal",h)}if(a.uvs.forEach(function(c,h){const l=h===0?"uv":`uv${h}`;i.setAttribute(l,new Pe(a.uvs[h],2))}),r.material&&r.material.mappingType!=="AllSame"){let c=a.materialIndex[0],h=0;if(a.materialIndex.forEach(function(l,d){l!==c&&(i.addGroup(h,d-h,c),c=l,h=d)}),i.groups.length>0){const l=i.groups[i.groups.length-1],d=l.start+l.count;d!==a.materialIndex.length&&i.addGroup(d,a.materialIndex.length-d,c)}i.groups.length===0&&i.addGroup(0,a.materialIndex.length,a.materialIndex[0])}return this.addMorphTargets(i,e,s,n),i}parseGeoNode(e,t){const s={};if(s.vertexPositions=e.Vertices!==void 0?e.Vertices.a:[],s.vertexIndices=e.PolygonVertexIndex!==void 0?e.PolygonVertexIndex.a:[],e.LayerElementColor&&(s.color=this.parseVertexColors(e.LayerElementColor[0])),e.LayerElementMaterial&&(s.material=this.parseMaterialIndices(e.LayerElementMaterial[0])),e.LayerElementNormal&&(s.normal=this.parseNormals(e.LayerElementNormal[0])),e.LayerElementUV){s.uv=[];let n=0;for(;e.LayerElementUV[n];)e.LayerElementUV[n].UV&&s.uv.push(this.parseUVs(e.LayerElementUV[n])),n++}return s.weightTable={},t!==null&&(s.skeleton=t,t.rawBones.forEach(function(n,i){n.indices.forEach(function(r,a){s.weightTable[r]===void 0&&(s.weightTable[r]=[]),s.weightTable[r].push({id:i,weight:n.weights[a]})})})),s}genBuffers(e){const t={vertex:[],normal:[],colors:[],uvs:[],materialIndex:[],vertexWeights:[],weightsIndices:[]};let s=0,n=0,i=!1,r=[],a=[],o=[],c=[],h=[],l=[];const d=this;return e.vertexIndices.forEach(function(p,w){let x,y=!1;p<0&&(p=p^-1,y=!0);let T=[],_=[];if(r.push(p*3,p*3+1,p*3+2),e.color){const b=St(w,s,p,e.color);o.push(b[0],b[1],b[2])}if(e.skeleton){if(e.weightTable[p]!==void 0&&e.weightTable[p].forEach(function(b){_.push(b.weight),T.push(b.id)}),_.length>4){i||(console.warn("THREE.FBXLoader: Vertex has more than 4 skinning weights assigned to vertex. Deleting additional weights."),i=!0);const b=[0,0,0,0],S=[0,0,0,0];_.forEach(function(P,C){let D=P,k=T[C];S.forEach(function(B,O,U){if(D>B){U[O]=D,D=B;const j=b[O];b[O]=k,k=j}})}),T=b,_=S}for(;_.length<4;)_.push(0),T.push(0);for(let b=0;b<4;++b)h.push(_[b]),l.push(T[b])}if(e.normal){const b=St(w,s,p,e.normal);a.push(b[0],b[1],b[2])}e.material&&e.material.mappingType!=="AllSame"&&(x=St(w,s,p,e.material)[0],x<0&&(d.negativeMaterialIndices=!0,x=0)),e.uv&&e.uv.forEach(function(b,S){const P=St(w,s,p,b);c[S]===void 0&&(c[S]=[]),c[S].push(P[0]),c[S].push(P[1])}),n++,y&&(d.genFace(t,e,r,x,a,o,c,h,l,n),s++,n=0,r=[],a=[],o=[],c=[],h=[],l=[])}),t}getNormalNewell(e){const t=new G(0,0,0);for(let s=0;s<e.length;s++){const n=e[s],i=e[(s+1)%e.length];t.x+=(n.y-i.y)*(n.z+i.z),t.y+=(n.z-i.z)*(n.x+i.x),t.z+=(n.x-i.x)*(n.y+i.y)}return t.normalize(),t}getNormalTangentAndBitangent(e){const t=this.getNormalNewell(e),n=(Math.abs(t.z)>.5?new G(0,1,0):new G(0,0,1)).cross(t).normalize(),i=t.clone().cross(n).normalize();return{normal:t,tangent:n,bitangent:i}}flattenVertex(e,t,s){return new Z(e.dot(t),e.dot(s))}genFace(e,t,s,n,i,r,a,o,c,h){let l;if(h>3){const d=[],p=t.baseVertexPositions||t.vertexPositions;for(let T=0;T<s.length;T+=3)d.push(new G(p[s[T]],p[s[T+1]],p[s[T+2]]));const{tangent:w,bitangent:x}=this.getNormalTangentAndBitangent(d),y=[];for(const T of d)y.push(this.flattenVertex(T,w,x));l=Us.triangulateShape(y,[])}else l=[[0,1,2]];for(const[d,p,w]of l)e.vertex.push(t.vertexPositions[s[d*3]]),e.vertex.push(t.vertexPositions[s[d*3+1]]),e.vertex.push(t.vertexPositions[s[d*3+2]]),e.vertex.push(t.vertexPositions[s[p*3]]),e.vertex.push(t.vertexPositions[s[p*3+1]]),e.vertex.push(t.vertexPositions[s[p*3+2]]),e.vertex.push(t.vertexPositions[s[w*3]]),e.vertex.push(t.vertexPositions[s[w*3+1]]),e.vertex.push(t.vertexPositions[s[w*3+2]]),t.skeleton&&(e.vertexWeights.push(o[d*4]),e.vertexWeights.push(o[d*4+1]),e.vertexWeights.push(o[d*4+2]),e.vertexWeights.push(o[d*4+3]),e.vertexWeights.push(o[p*4]),e.vertexWeights.push(o[p*4+1]),e.vertexWeights.push(o[p*4+2]),e.vertexWeights.push(o[p*4+3]),e.vertexWeights.push(o[w*4]),e.vertexWeights.push(o[w*4+1]),e.vertexWeights.push(o[w*4+2]),e.vertexWeights.push(o[w*4+3]),e.weightsIndices.push(c[d*4]),e.weightsIndices.push(c[d*4+1]),e.weightsIndices.push(c[d*4+2]),e.weightsIndices.push(c[d*4+3]),e.weightsIndices.push(c[p*4]),e.weightsIndices.push(c[p*4+1]),e.weightsIndices.push(c[p*4+2]),e.weightsIndices.push(c[p*4+3]),e.weightsIndices.push(c[w*4]),e.weightsIndices.push(c[w*4+1]),e.weightsIndices.push(c[w*4+2]),e.weightsIndices.push(c[w*4+3])),t.color&&(e.colors.push(r[d*3]),e.colors.push(r[d*3+1]),e.colors.push(r[d*3+2]),e.colors.push(r[p*3]),e.colors.push(r[p*3+1]),e.colors.push(r[p*3+2]),e.colors.push(r[w*3]),e.colors.push(r[w*3+1]),e.colors.push(r[w*3+2])),t.material&&t.material.mappingType!=="AllSame"&&(e.materialIndex.push(n),e.materialIndex.push(n),e.materialIndex.push(n)),t.normal&&(e.normal.push(i[d*3]),e.normal.push(i[d*3+1]),e.normal.push(i[d*3+2]),e.normal.push(i[p*3]),e.normal.push(i[p*3+1]),e.normal.push(i[p*3+2]),e.normal.push(i[w*3]),e.normal.push(i[w*3+1]),e.normal.push(i[w*3+2])),t.uv&&t.uv.forEach(function(x,y){e.uvs[y]===void 0&&(e.uvs[y]=[]),e.uvs[y].push(a[y][d*2]),e.uvs[y].push(a[y][d*2+1]),e.uvs[y].push(a[y][p*2]),e.uvs[y].push(a[y][p*2+1]),e.uvs[y].push(a[y][w*2]),e.uvs[y].push(a[y][w*2+1])})}addMorphTargets(e,t,s,n){if(s.length===0)return;e.morphTargetsRelative=!0,e.morphAttributes.position=[];const i=this;s.forEach(function(r){r.rawTargets.forEach(function(a){const o=J.Objects.Geometry[a.geoID];o!==void 0&&i.genMorphGeometry(e,t,o,n,a.name)})})}genMorphGeometry(e,t,s,n,i){const r=t.Vertices!==void 0?t.Vertices.a:[],a=t.PolygonVertexIndex!==void 0?t.PolygonVertexIndex.a:[],o=s.Vertices!==void 0?s.Vertices.a:[],c=s.Indexes!==void 0?s.Indexes.a:[],h=e.attributes.position.count*3,l=new Float32Array(h);for(let x=0;x<c.length;x++){const y=c[x]*3;l[y]=o[x*3],l[y+1]=o[x*3+1],l[y+2]=o[x*3+2]}const d={vertexIndices:a,vertexPositions:l,baseVertexPositions:r},p=this.genBuffers(d),w=new Pe(p.vertex,3);w.name=i||s.attrName,w.applyMatrix4(n),e.morphAttributes.position.push(w)}parseNormals(e){const t=e.MappingInformationType,s=e.ReferenceInformationType,n=e.Normals.a;let i=[];return s==="IndexToDirect"&&("NormalIndex"in e?i=e.NormalIndex.a:"NormalsIndex"in e&&(i=e.NormalsIndex.a)),{dataSize:3,buffer:n,indices:i,mappingType:t,referenceType:s}}parseUVs(e){const t=e.MappingInformationType,s=e.ReferenceInformationType,n=e.UV.a;let i=[];return s==="IndexToDirect"&&(i=e.UVIndex.a),{dataSize:2,buffer:n,indices:i,mappingType:t,referenceType:s}}parseVertexColors(e){const t=e.MappingInformationType,s=e.ReferenceInformationType,n=e.Colors.a;let i=[];s==="IndexToDirect"&&(i=e.ColorIndex.a);for(let r=0,a=new oe;r<n.length;r+=4)a.fromArray(n,r),Ie.toWorkingColorSpace(a,fe),a.toArray(n,r);return{dataSize:4,buffer:n,indices:i,mappingType:t,referenceType:s}}parseMaterialIndices(e){const t=e.MappingInformationType,s=e.ReferenceInformationType;if(t==="NoMappingInformation")return{dataSize:1,buffer:[0],indices:[0],mappingType:"AllSame",referenceType:s};const n=e.Materials.a,i=[];for(let r=0;r<n.length;++r)i.push(r);return{dataSize:1,buffer:n,indices:i,mappingType:t,referenceType:s}}parseNurbsGeometry(e){const t=parseInt(e.Order);if(isNaN(t))return console.error("THREE.FBXLoader: Invalid Order %s given for geometry ID: %s",e.Order,e.id),new ze;const s=t-1,n=e.KnotVector.a,i=[],r=e.Points.a;for(let l=0,d=r.length;l<d;l+=4)i.push(new Ne().fromArray(r,l));let a,o;if(e.Form==="Closed")i.push(i[0]);else if(e.Form==="Periodic"){a=s,o=n.length-1-a;for(let l=0;l<s;++l)i.push(i[l])}const h=new Zi(s,n,i,a,o).getPoints(i.length*12);return new ze().setFromPoints(h)}}class tr{parse(){const e=[],t=this.parseClips();if(t!==void 0)for(const s in t){const n=t[s],i=this.addClip(n);e.push(i)}return e}parseClips(){if(J.Objects.AnimationCurve===void 0)return;const e=this.parseAnimationCurveNodes();this.parseAnimationCurves(e);const t=this.parseAnimationLayers(e);return this.parseAnimStacks(t)}parseAnimationCurveNodes(){const e=J.Objects.AnimationCurveNode,t=new Map;for(const s in e){const n=e[s];if(n.attrName.match(/S|R|T|DeformPercent/)!==null){const i={id:n.id,attr:n.attrName,curves:{}};t.set(i.id,i)}}return t}parseAnimationCurves(e){const t=J.Objects.AnimationCurve;for(const s in t){const n={id:t[s].id,times:t[s].KeyTime.a.map(or),values:t[s].KeyValueFloat.a},i=de.get(n.id);if(i!==void 0){const r=i.parents[0].ID,a=i.parents[0].relationship;a.match(/X/)?e.get(r).curves.x=n:a.match(/Y/)?e.get(r).curves.y=n:a.match(/Z/)?e.get(r).curves.z=n:a.match(/DeformPercent/)&&e.has(r)&&(e.get(r).curves.morph=n)}}}parseAnimationLayers(e){const t=J.Objects.AnimationLayer,s=new Map;for(const n in t){const i=[],r=de.get(parseInt(n));r!==void 0&&(r.children.forEach(function(o,c){if(e.has(o.ID)){const h=e.get(o.ID);if(h.curves.x!==void 0||h.curves.y!==void 0||h.curves.z!==void 0){if(i[c]===void 0){const l=de.get(o.ID).parents.filter(function(d){return d.relationship!==void 0})[0].ID;if(l!==void 0){const d=J.Objects.Model[l.toString()];if(d===void 0){console.warn("THREE.FBXLoader: Encountered a unused curve.",o);return}const p={modelName:d.attrName?ut.sanitizeNodeName(d.attrName):"",ID:d.id,initialPosition:[0,0,0],initialRotation:[0,0,0],initialScale:[1,1,1]};xe.traverse(function(w){w.ID===d.id&&(p.transform=w.matrix,w.userData.transformData&&(p.eulerOrder=w.userData.transformData.eulerOrder))}),p.transform||(p.transform=new se),"PreRotation"in d&&(p.preRotation=d.PreRotation.value),"PostRotation"in d&&(p.postRotation=d.PostRotation.value),i[c]=p}}i[c]&&(i[c][h.attr]=h)}else if(h.curves.morph!==void 0){if(i[c]===void 0){const l=de.get(o.ID).parents.filter(function(T){return T.relationship!==void 0})[0].ID,d=de.get(l).parents[0].ID,p=de.get(d).parents[0].ID,w=de.get(p).parents[0].ID,x=J.Objects.Model[w],y={modelName:x.attrName?ut.sanitizeNodeName(x.attrName):"",morphName:J.Objects.Deformer[l].attrName};i[c]=y}i[c][h.attr]=h}}}),s.set(parseInt(n),i))}return s}parseAnimStacks(e){const t=J.Objects.AnimationStack,s={};for(const n in t){const i=de.get(parseInt(n)).children;i.length>1&&console.warn("THREE.FBXLoader: Encountered an animation stack with multiple layers, this is currently not supported. Ignoring subsequent layers.");const r=e.get(i[0].ID);s[n]={name:t[n].attrName,layer:r}}return s}addClip(e){let t=[];const s=this;return e.layer.forEach(function(n){t=t.concat(s.generateTracks(n))}),new zs(e.name,-1,t)}generateTracks(e){const t=[];let s=new G,n=new G;if(e.transform&&e.transform.decompose(s,new ge,n),s=s.toArray(),n=n.toArray(),e.T!==void 0&&Object.keys(e.T.curves).length>0){const i=this.generateVectorTrack(e.modelName,e.T.curves,s,"position");i!==void 0&&t.push(i)}if(e.R!==void 0&&Object.keys(e.R.curves).length>0){const i=this.generateRotationTrack(e.modelName,e.R.curves,e.preRotation,e.postRotation,e.eulerOrder);i!==void 0&&t.push(i)}if(e.S!==void 0&&Object.keys(e.S.curves).length>0){const i=this.generateVectorTrack(e.modelName,e.S.curves,n,"scale");i!==void 0&&t.push(i)}if(e.DeformPercent!==void 0){const i=this.generateMorphTrack(e);i!==void 0&&t.push(i)}return t}generateVectorTrack(e,t,s,n){const i=this.getTimesForAllAxes(t),r=this.getKeyframeTrackValues(i,t,s);return new es(e+"."+n,i,r)}generateRotationTrack(e,t,s,n,i){let r,a;if(t.x!==void 0&&t.y!==void 0&&t.z!==void 0){const d=this.interpolateRotations(t.x,t.y,t.z,i);r=d[0],a=d[1]}const o=pt(0);s!==void 0&&(s=s.map(me.degToRad),s.push(o),s=new Ve().fromArray(s),s=new ge().setFromEuler(s)),n!==void 0&&(n=n.map(me.degToRad),n.push(o),n=new Ve().fromArray(n),n=new ge().setFromEuler(n).invert());const c=new ge,h=new Ve,l=[];if(!a||!r)return new Pt(e+".quaternion",[0],[0]);for(let d=0;d<a.length;d+=3)h.set(a[d],a[d+1],a[d+2],i),c.setFromEuler(h),s!==void 0&&c.premultiply(s),n!==void 0&&c.multiply(n),d>2&&new ge().fromArray(l,(d-3)/3*4).dot(c)<0&&c.set(-c.x,-c.y,-c.z,-c.w),c.toArray(l,d/3*4);return new Pt(e+".quaternion",r,l)}generateMorphTrack(e){const t=e.DeformPercent.curves.morph,s=t.values.map(function(i){return i/100}),n=xe.getObjectByName(e.modelName).morphTargetDictionary[e.morphName];return new ts(e.modelName+".morphTargetInfluences["+n+"]",t.times,s)}getTimesForAllAxes(e){let t=[];if(e.x!==void 0&&(t=t.concat(e.x.times)),e.y!==void 0&&(t=t.concat(e.y.times)),e.z!==void 0&&(t=t.concat(e.z.times)),t=t.sort(function(s,n){return s-n}),t.length>1){let s=1,n=t[0];for(let i=1;i<t.length;i++){const r=t[i];r!==n&&(t[s]=r,n=r,s++)}t=t.slice(0,s)}return t}getKeyframeTrackValues(e,t,s){const n=s,i=[];let r=-1,a=-1,o=-1;return e.forEach(function(c){if(t.x&&(r=t.x.times.indexOf(c)),t.y&&(a=t.y.times.indexOf(c)),t.z&&(o=t.z.times.indexOf(c)),r!==-1){const h=t.x.values[r];i.push(h),n[0]=h}else i.push(n[0]);if(a!==-1){const h=t.y.values[a];i.push(h),n[1]=h}else i.push(n[1]);if(o!==-1){const h=t.z.values[o];i.push(h),n[2]=h}else i.push(n[2])}),i}interpolateRotations(e,t,s,n){const i=[],r=[];i.push(e.times[0]),r.push(me.degToRad(e.values[0])),r.push(me.degToRad(t.values[0])),r.push(me.degToRad(s.values[0]));for(let a=1;a<e.values.length;a++){const o=[e.values[a-1],t.values[a-1],s.values[a-1]];if(isNaN(o[0])||isNaN(o[1])||isNaN(o[2]))continue;const c=o.map(me.degToRad),h=[e.values[a],t.values[a],s.values[a]];if(isNaN(h[0])||isNaN(h[1])||isNaN(h[2]))continue;const l=h.map(me.degToRad),d=[h[0]-o[0],h[1]-o[1],h[2]-o[2]],p=[Math.abs(d[0]),Math.abs(d[1]),Math.abs(d[2])];if(p[0]>=180||p[1]>=180||p[2]>=180){const x=Math.max(...p)/180,y=new Ve(...c,n),T=new Ve(...l,n),_=new ge().setFromEuler(y),b=new ge().setFromEuler(T);_.dot(b)&&b.set(-b.x,-b.y,-b.z,-b.w);const S=e.times[a-1],P=e.times[a]-S,C=new ge,D=new Ve;for(let k=0;k<1;k+=1/x)C.copy(_.clone().slerp(b.clone(),k)),i.push(S+k*P),D.setFromQuaternion(C,n),r.push(D.x),r.push(D.y),r.push(D.z)}else i.push(e.times[a]),r.push(me.degToRad(e.values[a])),r.push(me.degToRad(t.values[a])),r.push(me.degToRad(s.values[a]))}return[i,r]}}class sr{getPrevNode(){return this.nodeStack[this.currentIndent-2]}getCurrentNode(){return this.nodeStack[this.currentIndent-1]}getCurrentProp(){return this.currentProp}pushStack(e){this.nodeStack.push(e),this.currentIndent+=1}popStack(){this.nodeStack.pop(),this.currentIndent-=1}setCurrentProp(e,t){this.currentProp=e,this.currentPropName=t}parse(e){this.currentIndent=0,this.allNodes=new rn,this.nodeStack=[],this.currentProp=[],this.currentPropName="";const t=this,s=e.split(/[\r\n]+/);return s.forEach(function(n,i){const r=n.match(/^[\s\t]*;/),a=n.match(/^[\s\t]*$/);if(r||a)return;const o=n.match("^\\t{"+t.currentIndent+"}(\\w+):(.*){",""),c=n.match("^\\t{"+t.currentIndent+"}(\\w+):[\\s\\t\\r\\n](.*)"),h=n.match("^\\t{"+(t.currentIndent-1)+"}}");o?t.parseNodeBegin(n,o):c?t.parseNodeProperty(n,c,s[++i]):h?t.popStack():n.match(/^[^\s\t}]/)&&t.parseNodePropertyContinued(n)}),this.allNodes}parseNodeBegin(e,t){const s=t[1].trim().replace(/^"/,"").replace(/"$/,""),n=t[2].split(",").map(function(o){return o.trim().replace(/^"/,"").replace(/"$/,"")}),i={name:s},r=this.parseNodeAttr(n),a=this.getCurrentNode();this.currentIndent===0?this.allNodes.add(s,i):s in a?(s==="PoseNode"?a.PoseNode.push(i):a[s].id!==void 0&&(a[s]={},a[s][a[s].id]=a[s]),r.id!==""&&(a[s][r.id]=i)):typeof r.id=="number"?(a[s]={},a[s][r.id]=i):s!=="Properties70"&&(s==="PoseNode"?a[s]=[i]:a[s]=i),typeof r.id=="number"&&(i.id=r.id),r.name!==""&&(i.attrName=r.name),r.type!==""&&(i.attrType=r.type),this.pushStack(i)}parseNodeAttr(e){let t=e[0];e[0]!==""&&(t=parseInt(e[0]),isNaN(t)&&(t=e[0]));let s="",n="";return e.length>1&&(s=e[1].replace(/^(\w+)::/,""),n=e[2]),{id:t,name:s,type:n}}parseNodeProperty(e,t,s){let n=t[1].replace(/^"/,"").replace(/"$/,"").trim(),i=t[2].replace(/^"/,"").replace(/"$/,"").trim();n==="Content"&&i===","&&(i=s.replace(/"/g,"").replace(/,$/,"").trim());const r=this.getCurrentNode();if(r.name==="Properties70"){this.parseNodeSpecialProperty(e,n,i);return}if(n==="C"){const o=i.split(",").slice(1),c=parseInt(o[0]),h=parseInt(o[1]);let l=i.split(",").slice(3);l=l.map(function(d){return d.trim().replace(/^"/,"")}),n="connections",i=[c,h],cr(i,l),r[n]===void 0&&(r[n]=[])}n==="Node"&&(r.id=i),n in r&&Array.isArray(r[n])?r[n].push(i):n!=="a"?r[n]=i:r.a=i,this.setCurrentProp(r,n),n==="a"&&i.slice(-1)!==","&&(r.a=Wt(i))}parseNodePropertyContinued(e){const t=this.getCurrentNode();t.a+=e,e.slice(-1)!==","&&(t.a=Wt(t.a))}parseNodeSpecialProperty(e,t,s){const n=s.split('",').map(function(h){return h.trim().replace(/^\"/,"").replace(/\s/,"_")}),i=n[0],r=n[1],a=n[2],o=n[3];let c=n[4];switch(r){case"int":case"enum":case"bool":case"ULongLong":case"double":case"Number":case"FieldOfView":c=parseFloat(c);break;case"Color":case"ColorRGB":case"Vector3D":case"Lcl_Translation":case"Lcl_Rotation":case"Lcl_Scaling":c=Wt(c);break}this.getPrevNode()[i]={type:r,type2:a,flag:o,value:c},this.setCurrentProp(this.getPrevNode(),i)}}class nr{parse(e){const t=new As(e);t.skip(23);const s=t.getUint32();if(s<6400)throw new Error("THREE.FBXLoader: FBX version not supported, FileVersion: "+s);const n=new rn;for(;!this.endOfContent(t);){const i=this.parseNode(t,s);i!==null&&n.add(i.name,i)}return n}endOfContent(e){return e.size()%16===0?(e.getOffset()+160+16&-16)>=e.size():e.getOffset()+160+16>=e.size()}parseNode(e,t){const s={},n=t>=7500?e.getUint64():e.getUint32(),i=t>=7500?e.getUint64():e.getUint32();t>=7500?e.getUint64():e.getUint32();const r=e.getUint8(),a=e.getString(r);if(n===0)return null;const o=[];for(let d=0;d<i;d++)o.push(this.parseProperty(e));const c=o.length>0?o[0]:"",h=o.length>1?o[1]:"",l=o.length>2?o[2]:"";for(s.singleProperty=i===1&&e.getOffset()===n;n>e.getOffset();){const d=this.parseNode(e,t);d!==null&&this.parseSubNode(a,s,d)}return s.propertyList=o,typeof c=="number"&&(s.id=c),h!==""&&(s.attrName=h),l!==""&&(s.attrType=l),a!==""&&(s.name=a),s}parseSubNode(e,t,s){if(s.singleProperty===!0){const n=s.propertyList[0];Array.isArray(n)?(t[s.name]=s,s.a=n):t[s.name]=n}else if(e==="Connections"&&s.name==="C"){const n=[];s.propertyList.forEach(function(i,r){r!==0&&n.push(i)}),t.connections===void 0&&(t.connections=[]),t.connections.push(n)}else if(s.name==="Properties70")Object.keys(s).forEach(function(i){t[i]=s[i]});else if(e==="Properties70"&&s.name==="P"){let n=s.propertyList[0],i=s.propertyList[1];const r=s.propertyList[2],a=s.propertyList[3];let o;n.indexOf("Lcl ")===0&&(n=n.replace("Lcl ","Lcl_")),i.indexOf("Lcl ")===0&&(i=i.replace("Lcl ","Lcl_")),i==="Color"||i==="ColorRGB"||i==="Vector"||i==="Vector3D"||i.indexOf("Lcl_")===0?o=[s.propertyList[4],s.propertyList[5],s.propertyList[6]]:o=s.propertyList[4],t[n]={type:i,type2:r,flag:a,value:o}}else t[s.name]===void 0?typeof s.id=="number"?(t[s.name]={},t[s.name][s.id]=s):t[s.name]=s:s.name==="PoseNode"?(Array.isArray(t[s.name])||(t[s.name]=[t[s.name]]),t[s.name].push(s)):t[s.name][s.id]===void 0&&(t[s.name][s.id]=s)}parseProperty(e){const t=e.getString(1);let s;switch(t){case"C":return e.getBoolean();case"D":return e.getFloat64();case"F":return e.getFloat32();case"I":return e.getInt32();case"L":return e.getInt64();case"R":return s=e.getUint32(),e.getArrayBuffer(s);case"S":return s=e.getUint32(),e.getString(s);case"Y":return e.getInt16();case"b":case"c":case"d":case"f":case"i":case"l":const n=e.getUint32(),i=e.getUint32(),r=e.getUint32();if(i===0)switch(t){case"b":case"c":return e.getBooleanArray(n);case"d":return e.getFloat64Array(n);case"f":return e.getFloat32Array(n);case"i":return e.getInt32Array(n);case"l":return e.getInt64Array(n)}const a=zi(new Uint8Array(e.getArrayBuffer(r))),o=new As(a.buffer);switch(t){case"b":case"c":return o.getBooleanArray(n);case"d":return o.getFloat64Array(n);case"f":return o.getFloat32Array(n);case"i":return o.getInt32Array(n);case"l":return o.getInt64Array(n)}break;default:throw new Error("THREE.FBXLoader: Unknown property type "+t)}}}class As{constructor(e,t){this.dv=new DataView(e),this.offset=0,this.littleEndian=t!==void 0?t:!0,this._textDecoder=new TextDecoder}getOffset(){return this.offset}size(){return this.dv.buffer.byteLength}skip(e){this.offset+=e}getBoolean(){return(this.getUint8()&1)===1}getBooleanArray(e){const t=[];for(let s=0;s<e;s++)t.push(this.getBoolean());return t}getUint8(){const e=this.dv.getUint8(this.offset);return this.offset+=1,e}getInt16(){const e=this.dv.getInt16(this.offset,this.littleEndian);return this.offset+=2,e}getInt32(){const e=this.dv.getInt32(this.offset,this.littleEndian);return this.offset+=4,e}getInt32Array(e){const t=[];for(let s=0;s<e;s++)t.push(this.getInt32());return t}getUint32(){const e=this.dv.getUint32(this.offset,this.littleEndian);return this.offset+=4,e}getInt64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),t&2147483648?(t=~t&4294967295,e=~e&4294967295,e===4294967295&&(t=t+1&4294967295),e=e+1&4294967295,-(t*4294967296+e)):t*4294967296+e}getInt64Array(e){const t=[];for(let s=0;s<e;s++)t.push(this.getInt64());return t}getUint64(){let e,t;return this.littleEndian?(e=this.getUint32(),t=this.getUint32()):(t=this.getUint32(),e=this.getUint32()),t*4294967296+e}getFloat32(){const e=this.dv.getFloat32(this.offset,this.littleEndian);return this.offset+=4,e}getFloat32Array(e){const t=[];for(let s=0;s<e;s++)t.push(this.getFloat32());return t}getFloat64(){const e=this.dv.getFloat64(this.offset,this.littleEndian);return this.offset+=8,e}getFloat64Array(e){const t=[];for(let s=0;s<e;s++)t.push(this.getFloat64());return t}getArrayBuffer(e){const t=this.dv.buffer.slice(this.offset,this.offset+e);return this.offset+=e,t}getString(e){const t=this.offset;let s=new Uint8Array(this.dv.buffer,t,e);this.skip(e);const n=s.indexOf(0);return n>=0&&(s=new Uint8Array(this.dv.buffer,t,n)),this._textDecoder.decode(s)}}class rn{add(e,t){this[e]=t}}function ir(u){const e="Kaydara FBX Binary  \0";return u.byteLength>=e.length&&e===an(u,0,e.length)}function rr(u){const e=["K","a","y","d","a","r","a","\\","F","B","X","\\","B","i","n","a","r","y","\\","\\"];let t=0;function s(n){const i=u[n-1];return u=u.slice(t+n),t++,i}for(let n=0;n<e.length;++n)if(s(1)===e[n])return!1;return!0}function Ts(u){const e=/FBXVersion: (\d+)/,t=u.match(e);if(t)return parseInt(t[1]);throw new Error("THREE.FBXLoader: Cannot find the version number for the file given.")}function or(u){return u/46186158e3}const ar=[];function St(u,e,t,s){let n;switch(s.mappingType){case"ByPolygonVertex":n=u;break;case"ByPolygon":n=e;break;case"ByVertice":n=t;break;case"AllSame":n=s.indices[0];break;default:console.warn("THREE.FBXLoader: unknown attribute mapping type "+s.mappingType)}s.referenceType==="IndexToDirect"&&(n=s.indices[n]);const i=n*s.dataSize,r=i+s.dataSize;return lr(ar,s.buffer,i,r)}const Ht=new Ve,$e=new G;function on(u){const e=new se,t=new se,s=new se,n=new se,i=new se,r=new se,a=new se,o=new se,c=new se,h=new se,l=new se,d=new se,p=u.inheritType?u.inheritType:0;u.translation&&e.setPosition($e.fromArray(u.translation));const w=pt(0);if(u.preRotation){const U=u.preRotation.map(me.degToRad);U.push(w),t.makeRotationFromEuler(Ht.fromArray(U))}if(u.rotation){const U=u.rotation.map(me.degToRad);U.push(u.eulerOrder||w),s.makeRotationFromEuler(Ht.fromArray(U))}if(u.postRotation){const U=u.postRotation.map(me.degToRad);U.push(w),n.makeRotationFromEuler(Ht.fromArray(U)),n.invert()}u.scale&&i.scale($e.fromArray(u.scale)),u.scalingOffset&&a.setPosition($e.fromArray(u.scalingOffset)),u.scalingPivot&&r.setPosition($e.fromArray(u.scalingPivot)),u.rotationOffset&&o.setPosition($e.fromArray(u.rotationOffset)),u.rotationPivot&&c.setPosition($e.fromArray(u.rotationPivot)),u.parentMatrixWorld&&(l.copy(u.parentMatrix),h.copy(u.parentMatrixWorld));const x=t.clone().multiply(s).multiply(n),y=new se;y.extractRotation(h);const T=new se;T.copyPosition(h);const _=T.clone().invert().multiply(h),b=y.clone().invert().multiply(_),S=i,P=new se;if(p===0)P.copy(y).multiply(x).multiply(b).multiply(S);else if(p===1)P.copy(y).multiply(b).multiply(x).multiply(S);else{const j=new se().scale(new G().setFromMatrixScale(l)).clone().invert(),$=b.clone().multiply(j);P.copy(y).multiply(x).multiply($).multiply(S)}const C=c.clone().invert(),D=r.clone().invert();let k=e.clone().multiply(o).multiply(c).multiply(t).multiply(s).multiply(n).multiply(C).multiply(a).multiply(r).multiply(i).multiply(D);const B=new se().copyPosition(k),O=h.clone().multiply(B);return d.copyPosition(O),k=d.clone().multiply(P),k.premultiply(h.invert()),k}function pt(u){u=u||0;const e=["ZYX","YZX","XZY","ZXY","YXZ","XYZ"];return u===6?(console.warn("THREE.FBXLoader: unsupported Euler Order: Spherical XYZ. Animations and rotations may be incorrect."),e[0]):e[u]}function Wt(u){return u.split(",").map(function(t){return parseFloat(t)})}function an(u,e,t){return e===void 0&&(e=0),t===void 0&&(t=u.byteLength),new TextDecoder().decode(new Uint8Array(u,e,t))}function cr(u,e){for(let t=0,s=u.length,n=e.length;t<n;t++,s++)u[s]=e[t]}function lr(u,e,t,s){for(let n=t,i=0;n<s;n++,i++)u[i]=e[n];return u}function vs(u,e){if(e===Un)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),u;if(e===ss||e===js){let t=u.getIndex();if(t===null){const r=[],a=u.getAttribute("position");if(a!==void 0){for(let o=0;o<a.count;o++)r.push(o);u.setIndex(r),t=u.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),u}const s=t.count-2,n=[];if(e===ss)for(let r=1;r<=s;r++)n.push(t.getX(0)),n.push(t.getX(r)),n.push(t.getX(r+1));else for(let r=0;r<s;r++)r%2===0?(n.push(t.getX(r)),n.push(t.getX(r+1)),n.push(t.getX(r+2))):(n.push(t.getX(r+2)),n.push(t.getX(r+1)),n.push(t.getX(r)));n.length/3!==s&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const i=u.clone();return i.setIndex(n),i.clearGroups(),i}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),u}class cn extends ht{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new fr(t)}),this.register(function(t){return new mr(t)}),this.register(function(t){return new Mr(t)}),this.register(function(t){return new Sr(t)}),this.register(function(t){return new Er(t)}),this.register(function(t){return new yr(t)}),this.register(function(t){return new xr(t)}),this.register(function(t){return new wr(t)}),this.register(function(t){return new br(t)}),this.register(function(t){return new pr(t)}),this.register(function(t){return new Ar(t)}),this.register(function(t){return new gr(t)}),this.register(function(t){return new vr(t)}),this.register(function(t){return new Tr(t)}),this.register(function(t){return new ur(t)}),this.register(function(t){return new _r(t)}),this.register(function(t){return new Pr(t)})}load(e,t,s,n){const i=this;let r;if(this.resourcePath!=="")r=this.resourcePath;else if(this.path!==""){const c=tt.extractUrlBase(e);r=tt.resolveURL(c,this.path)}else r=tt.extractUrlBase(e);this.manager.itemStart(e);const a=function(c){n?n(c):console.error(c),i.manager.itemError(e),i.manager.itemEnd(e)},o=new wt(this.manager);o.setPath(this.path),o.setResponseType("arraybuffer"),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(c){try{i.parse(c,r,function(h){t(h),i.manager.itemEnd(e)},a)}catch(h){a(h)}},s,a)}setDRACOLoader(e){return this.dracoLoader=e,this}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,s,n){let i;const r={},a={},o=new TextDecoder;if(typeof e=="string")i=JSON.parse(e);else if(e instanceof ArrayBuffer)if(o.decode(new Uint8Array(e,0,4))===ln){try{r[ee.KHR_BINARY_GLTF]=new Rr(e)}catch(l){n&&n(l);return}i=JSON.parse(r[ee.KHR_BINARY_GLTF].content)}else i=JSON.parse(o.decode(e));else i=e;if(i.asset===void 0||i.asset.version[0]<2){n&&n(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const c=new jr(i,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});c.fileLoader.setRequestHeader(this.requestHeader);for(let h=0;h<this.pluginCallbacks.length;h++){const l=this.pluginCallbacks[h](c);l.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),a[l.name]=l,r[l.name]=!0}if(i.extensionsUsed)for(let h=0;h<i.extensionsUsed.length;++h){const l=i.extensionsUsed[h],d=i.extensionsRequired||[];switch(l){case ee.KHR_MATERIALS_UNLIT:r[l]=new dr;break;case ee.KHR_DRACO_MESH_COMPRESSION:r[l]=new Cr(i,this.dracoLoader);break;case ee.KHR_TEXTURE_TRANSFORM:r[l]=new Lr;break;case ee.KHR_MESH_QUANTIZATION:r[l]=new Ir;break;default:d.indexOf(l)>=0&&a[l]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+l+'".')}}c.setExtensions(r),c.setPlugins(a),c.parse(s,n)}parseAsync(e,t){const s=this;return new Promise(function(n,i){s.parse(e,t,n,i)})}}function hr(){let u={};return{get:function(e){return u[e]},add:function(e,t){u[e]=t},remove:function(e){delete u[e]},removeAll:function(){u={}}}}const ee={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_DISPERSION:"KHR_materials_dispersion",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class ur{constructor(e){this.parser=e,this.name=ee.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let s=0,n=t.length;s<n;s++){const i=t[s];i.extensions&&i.extensions[this.name]&&i.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,i.extensions[this.name].light)}}_loadLight(e){const t=this.parser,s="light:"+e;let n=t.cache.get(s);if(n)return n;const i=t.json,o=((i.extensions&&i.extensions[this.name]||{}).lights||[])[e];let c;const h=new oe(16777215);o.color!==void 0&&h.setRGB(o.color[0],o.color[1],o.color[2],Ge);const l=o.range!==void 0?o.range:0;switch(o.type){case"directional":c=new hs(h),c.target.position.set(0,0,-1),c.add(c.target);break;case"point":c=new _t(h),c.distance=l;break;case"spot":c=new ls(h),c.distance=l,o.spot=o.spot||{},o.spot.innerConeAngle=o.spot.innerConeAngle!==void 0?o.spot.innerConeAngle:0,o.spot.outerConeAngle=o.spot.outerConeAngle!==void 0?o.spot.outerConeAngle:Math.PI/4,c.angle=o.spot.outerConeAngle,c.penumbra=1-o.spot.innerConeAngle/o.spot.outerConeAngle,c.target.position.set(0,0,-1),c.add(c.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+o.type)}return c.position.set(0,0,0),c.decay=2,Be(c,o),o.intensity!==void 0&&(c.intensity=o.intensity),c.name=t.createUniqueName(o.name||"light_"+e),n=Promise.resolve(c),t.cache.add(s,n),n}getDependency(e,t){if(e==="light")return this._loadLight(t)}createNodeAttachment(e){const t=this,s=this.parser,i=s.json.nodes[e],a=(i.extensions&&i.extensions[this.name]||{}).light;return a===void 0?null:this._loadLight(a).then(function(o){return s._getNodeRef(t.cache,a,o)})}}class dr{constructor(){this.name=ee.KHR_MATERIALS_UNLIT}getMaterialType(){return De}extendParams(e,t,s){const n=[];e.color=new oe(1,1,1),e.opacity=1;const i=t.pbrMetallicRoughness;if(i){if(Array.isArray(i.baseColorFactor)){const r=i.baseColorFactor;e.color.setRGB(r[0],r[1],r[2],Ge),e.opacity=r[3]}i.baseColorTexture!==void 0&&n.push(s.assignTexture(e,"map",i.baseColorTexture,fe))}return Promise.all(n)}}class pr{constructor(e){this.parser=e,this.name=ee.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const n=this.parser.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=n.extensions[this.name].emissiveStrength;return i!==void 0&&(t.emissiveIntensity=i),Promise.resolve()}}class fr{constructor(e){this.parser=e,this.name=ee.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Re}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],r=n.extensions[this.name];if(r.clearcoatFactor!==void 0&&(t.clearcoat=r.clearcoatFactor),r.clearcoatTexture!==void 0&&i.push(s.assignTexture(t,"clearcoatMap",r.clearcoatTexture)),r.clearcoatRoughnessFactor!==void 0&&(t.clearcoatRoughness=r.clearcoatRoughnessFactor),r.clearcoatRoughnessTexture!==void 0&&i.push(s.assignTexture(t,"clearcoatRoughnessMap",r.clearcoatRoughnessTexture)),r.clearcoatNormalTexture!==void 0&&(i.push(s.assignTexture(t,"clearcoatNormalMap",r.clearcoatNormalTexture)),r.clearcoatNormalTexture.scale!==void 0)){const a=r.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new Z(a,a)}return Promise.all(i)}}class mr{constructor(e){this.parser=e,this.name=ee.KHR_MATERIALS_DISPERSION}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Re}extendMaterialParams(e,t){const n=this.parser.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=n.extensions[this.name];return t.dispersion=i.dispersion!==void 0?i.dispersion:0,Promise.resolve()}}class gr{constructor(e){this.parser=e,this.name=ee.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Re}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],r=n.extensions[this.name];return r.iridescenceFactor!==void 0&&(t.iridescence=r.iridescenceFactor),r.iridescenceTexture!==void 0&&i.push(s.assignTexture(t,"iridescenceMap",r.iridescenceTexture)),r.iridescenceIor!==void 0&&(t.iridescenceIOR=r.iridescenceIor),t.iridescenceThicknessRange===void 0&&(t.iridescenceThicknessRange=[100,400]),r.iridescenceThicknessMinimum!==void 0&&(t.iridescenceThicknessRange[0]=r.iridescenceThicknessMinimum),r.iridescenceThicknessMaximum!==void 0&&(t.iridescenceThicknessRange[1]=r.iridescenceThicknessMaximum),r.iridescenceThicknessTexture!==void 0&&i.push(s.assignTexture(t,"iridescenceThicknessMap",r.iridescenceThicknessTexture)),Promise.all(i)}}class yr{constructor(e){this.parser=e,this.name=ee.KHR_MATERIALS_SHEEN}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Re}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[];t.sheenColor=new oe(0,0,0),t.sheenRoughness=0,t.sheen=1;const r=n.extensions[this.name];if(r.sheenColorFactor!==void 0){const a=r.sheenColorFactor;t.sheenColor.setRGB(a[0],a[1],a[2],Ge)}return r.sheenRoughnessFactor!==void 0&&(t.sheenRoughness=r.sheenRoughnessFactor),r.sheenColorTexture!==void 0&&i.push(s.assignTexture(t,"sheenColorMap",r.sheenColorTexture,fe)),r.sheenRoughnessTexture!==void 0&&i.push(s.assignTexture(t,"sheenRoughnessMap",r.sheenRoughnessTexture)),Promise.all(i)}}class xr{constructor(e){this.parser=e,this.name=ee.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Re}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],r=n.extensions[this.name];return r.transmissionFactor!==void 0&&(t.transmission=r.transmissionFactor),r.transmissionTexture!==void 0&&i.push(s.assignTexture(t,"transmissionMap",r.transmissionTexture)),Promise.all(i)}}class wr{constructor(e){this.parser=e,this.name=ee.KHR_MATERIALS_VOLUME}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Re}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],r=n.extensions[this.name];t.thickness=r.thicknessFactor!==void 0?r.thicknessFactor:0,r.thicknessTexture!==void 0&&i.push(s.assignTexture(t,"thicknessMap",r.thicknessTexture)),t.attenuationDistance=r.attenuationDistance||1/0;const a=r.attenuationColor||[1,1,1];return t.attenuationColor=new oe().setRGB(a[0],a[1],a[2],Ge),Promise.all(i)}}class br{constructor(e){this.parser=e,this.name=ee.KHR_MATERIALS_IOR}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Re}extendMaterialParams(e,t){const n=this.parser.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=n.extensions[this.name];return t.ior=i.ior!==void 0?i.ior:1.5,Promise.resolve()}}class Ar{constructor(e){this.parser=e,this.name=ee.KHR_MATERIALS_SPECULAR}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Re}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],r=n.extensions[this.name];t.specularIntensity=r.specularFactor!==void 0?r.specularFactor:1,r.specularTexture!==void 0&&i.push(s.assignTexture(t,"specularIntensityMap",r.specularTexture));const a=r.specularColorFactor||[1,1,1];return t.specularColor=new oe().setRGB(a[0],a[1],a[2],Ge),r.specularColorTexture!==void 0&&i.push(s.assignTexture(t,"specularColorMap",r.specularColorTexture,fe)),Promise.all(i)}}class Tr{constructor(e){this.parser=e,this.name=ee.EXT_MATERIALS_BUMP}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Re}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],r=n.extensions[this.name];return t.bumpScale=r.bumpFactor!==void 0?r.bumpFactor:1,r.bumpTexture!==void 0&&i.push(s.assignTexture(t,"bumpMap",r.bumpTexture)),Promise.all(i)}}class vr{constructor(e){this.parser=e,this.name=ee.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const s=this.parser.json.materials[e];return!s.extensions||!s.extensions[this.name]?null:Re}extendMaterialParams(e,t){const s=this.parser,n=s.json.materials[e];if(!n.extensions||!n.extensions[this.name])return Promise.resolve();const i=[],r=n.extensions[this.name];return r.anisotropyStrength!==void 0&&(t.anisotropy=r.anisotropyStrength),r.anisotropyRotation!==void 0&&(t.anisotropyRotation=r.anisotropyRotation),r.anisotropyTexture!==void 0&&i.push(s.assignTexture(t,"anisotropyMap",r.anisotropyTexture)),Promise.all(i)}}class Mr{constructor(e){this.parser=e,this.name=ee.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,s=t.json,n=s.textures[e];if(!n.extensions||!n.extensions[this.name])return null;const i=n.extensions[this.name],r=t.options.ktx2Loader;if(!r){if(s.extensionsRequired&&s.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,i.source,r)}}class Sr{constructor(e){this.parser=e,this.name=ee.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,s=this.parser,n=s.json,i=n.textures[e];if(!i.extensions||!i.extensions[t])return null;const r=i.extensions[t],a=n.images[r.source];let o=s.textureLoader;if(a.uri){const c=s.options.manager.getHandler(a.uri);c!==null&&(o=c)}return this.detectSupport().then(function(c){if(c)return s.loadTextureImage(e,r.source,o);if(n.extensionsRequired&&n.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return s.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class Er{constructor(e){this.parser=e,this.name=ee.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(e){const t=this.name,s=this.parser,n=s.json,i=n.textures[e];if(!i.extensions||!i.extensions[t])return null;const r=i.extensions[t],a=n.images[r.source];let o=s.textureLoader;if(a.uri){const c=s.options.manager.getHandler(a.uri);c!==null&&(o=c)}return this.detectSupport().then(function(c){if(c)return s.loadTextureImage(e,r.source,o);if(n.extensionsRequired&&n.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return s.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class _r{constructor(e){this.name=ee.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,s=t.bufferViews[e];if(s.extensions&&s.extensions[this.name]){const n=s.extensions[this.name],i=this.parser.getDependency("buffer",n.buffer),r=this.parser.options.meshoptDecoder;if(!r||!r.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return i.then(function(a){const o=n.byteOffset||0,c=n.byteLength||0,h=n.count,l=n.byteStride,d=new Uint8Array(a,o,c);return r.decodeGltfBufferAsync?r.decodeGltfBufferAsync(h,l,d,n.mode,n.filter).then(function(p){return p.buffer}):r.ready.then(function(){const p=new ArrayBuffer(h*l);return r.decodeGltfBuffer(new Uint8Array(p),h,l,d,n.mode,n.filter),p})})}else return null}}class Pr{constructor(e){this.name=ee.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,s=t.nodes[e];if(!s.extensions||!s.extensions[this.name]||s.mesh===void 0)return null;const n=t.meshes[s.mesh];for(const c of n.primitives)if(c.mode!==ve.TRIANGLES&&c.mode!==ve.TRIANGLE_STRIP&&c.mode!==ve.TRIANGLE_FAN&&c.mode!==void 0)return null;const r=s.extensions[this.name].attributes,a=[],o={};for(const c in r)a.push(this.parser.getDependency("accessor",r[c]).then(h=>(o[c]=h,o[c])));return a.length<1?null:(a.push(this.parser.createNodeMesh(e)),Promise.all(a).then(c=>{const h=c.pop(),l=h.isGroup?h.children:[h],d=c[0].count,p=[];for(const w of l){const x=new se,y=new G,T=new ge,_=new G(1,1,1),b=new zn(w.geometry,w.material,d);for(let S=0;S<d;S++)o.TRANSLATION&&y.fromBufferAttribute(o.TRANSLATION,S),o.ROTATION&&T.fromBufferAttribute(o.ROTATION,S),o.SCALE&&_.fromBufferAttribute(o.SCALE,S),b.setMatrixAt(S,x.compose(y,T,_));for(const S in o)if(S==="_COLOR_0"){const P=o[S];b.instanceColor=new jn(P.array,P.itemSize,P.normalized)}else S!=="TRANSLATION"&&S!=="ROTATION"&&S!=="SCALE"&&w.geometry.setAttribute(S,o[S]);Ue.prototype.copy.call(b,w),this.parser.assignFinalMaterial(b),p.push(b)}return h.isGroup?(h.clear(),h.add(...p),h):p[0]}))}}const ln="glTF",ot=12,Ms={JSON:1313821514,BIN:5130562};class Rr{constructor(e){this.name=ee.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,ot),s=new TextDecoder;if(this.header={magic:s.decode(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==ln)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const n=this.header.length-ot,i=new DataView(e,ot);let r=0;for(;r<n;){const a=i.getUint32(r,!0);r+=4;const o=i.getUint32(r,!0);if(r+=4,o===Ms.JSON){const c=new Uint8Array(e,ot+r,a);this.content=s.decode(c)}else if(o===Ms.BIN){const c=ot+r;this.body=e.slice(c,c+a)}r+=a}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class Cr{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=ee.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const s=this.json,n=this.dracoLoader,i=e.extensions[this.name].bufferView,r=e.extensions[this.name].attributes,a={},o={},c={};for(const h in r){const l=rs[h]||h.toLowerCase();a[l]=r[h]}for(const h in e.attributes){const l=rs[h]||h.toLowerCase();if(r[h]!==void 0){const d=s.accessors[e.attributes[h]],p=it[d.componentType];c[l]=p.name,o[l]=d.normalized===!0}}return t.getDependency("bufferView",i).then(function(h){return new Promise(function(l,d){n.decodeDracoFile(h,function(p){for(const w in p.attributes){const x=p.attributes[w],y=o[w];y!==void 0&&(x.normalized=y)}l(p)},a,c,Ge,d)})})}}class Lr{constructor(){this.name=ee.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return(t.texCoord===void 0||t.texCoord===e.channel)&&t.offset===void 0&&t.rotation===void 0&&t.scale===void 0||(e=e.clone(),t.texCoord!==void 0&&(e.channel=t.texCoord),t.offset!==void 0&&e.offset.fromArray(t.offset),t.rotation!==void 0&&(e.rotation=t.rotation),t.scale!==void 0&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class Ir{constructor(){this.name=ee.KHR_MESH_QUANTIZATION}}class hn extends Jn{constructor(e,t,s,n){super(e,t,s,n)}copySampleValue_(e){const t=this.resultBuffer,s=this.sampleValues,n=this.valueSize,i=e*n*3+n;for(let r=0;r!==n;r++)t[r]=s[i+r];return t}interpolate_(e,t,s,n){const i=this.resultBuffer,r=this.sampleValues,a=this.valueSize,o=a*2,c=a*3,h=n-t,l=(s-t)/h,d=l*l,p=d*l,w=e*c,x=w-c,y=-2*p+3*d,T=p-d,_=1-y,b=T-d+l;for(let S=0;S!==a;S++){const P=r[x+S+a],C=r[x+S+o]*h,D=r[w+S+a],k=r[w+S]*h;i[S]=_*P+b*C+y*D+T*k}return i}}const kr=new ge;class Dr extends hn{interpolate_(e,t,s,n){const i=super.interpolate_(e,t,s,n);return kr.fromArray(i).normalize().toArray(i),i}}const ve={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6},it={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},Ss={9728:Hs,9729:ns,9984:Kn,9985:Xn,9986:Wn,9987:Gs},Es={33071:Zt,33648:qn,10497:je},Xt={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},rs={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},Xe={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},Or={CUBICSPLINE:void 0,LINEAR:Ws,STEP:Qn},Kt={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function Fr(u){return u.DefaultMaterial===void 0&&(u.DefaultMaterial=new Dt({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:$n})),u.DefaultMaterial}function Qe(u,e,t){for(const s in t.extensions)u[s]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[s]=t.extensions[s])}function Be(u,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(u.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function Nr(u,e,t){let s=!1,n=!1,i=!1;for(let c=0,h=e.length;c<h;c++){const l=e[c];if(l.POSITION!==void 0&&(s=!0),l.NORMAL!==void 0&&(n=!0),l.COLOR_0!==void 0&&(i=!0),s&&n&&i)break}if(!s&&!n&&!i)return Promise.resolve(u);const r=[],a=[],o=[];for(let c=0,h=e.length;c<h;c++){const l=e[c];if(s){const d=l.POSITION!==void 0?t.getDependency("accessor",l.POSITION):u.attributes.position;r.push(d)}if(n){const d=l.NORMAL!==void 0?t.getDependency("accessor",l.NORMAL):u.attributes.normal;a.push(d)}if(i){const d=l.COLOR_0!==void 0?t.getDependency("accessor",l.COLOR_0):u.attributes.color;o.push(d)}}return Promise.all([Promise.all(r),Promise.all(a),Promise.all(o)]).then(function(c){const h=c[0],l=c[1],d=c[2];return s&&(u.morphAttributes.position=h),n&&(u.morphAttributes.normal=l),i&&(u.morphAttributes.color=d),u.morphTargetsRelative=!0,u})}function Br(u,e){if(u.updateMorphTargets(),e.weights!==void 0)for(let t=0,s=e.weights.length;t<s;t++)u.morphTargetInfluences[t]=e.weights[t];if(e.extras&&Array.isArray(e.extras.targetNames)){const t=e.extras.targetNames;if(u.morphTargetInfluences.length===t.length){u.morphTargetDictionary={};for(let s=0,n=t.length;s<n;s++)u.morphTargetDictionary[t[s]]=s}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function Vr(u){let e;const t=u.extensions&&u.extensions[ee.KHR_DRACO_MESH_COMPRESSION];if(t?e="draco:"+t.bufferView+":"+t.indices+":"+qt(t.attributes):e=u.indices+":"+qt(u.attributes)+":"+u.mode,u.targets!==void 0)for(let s=0,n=u.targets.length;s<n;s++)e+=":"+qt(u.targets[s]);return e}function qt(u){let e="";const t=Object.keys(u).sort();for(let s=0,n=t.length;s<n;s++)e+=t[s]+":"+u[t[s]]+";";return e}function os(u){switch(u){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function Ur(u){return u.search(/\.jpe?g($|\?)/i)>0||u.search(/^data\:image\/jpeg/)===0?"image/jpeg":u.search(/\.webp($|\?)/i)>0||u.search(/^data\:image\/webp/)===0?"image/webp":u.search(/\.ktx2($|\?)/i)>0||u.search(/^data\:image\/ktx2/)===0?"image/ktx2":"image/png"}const zr=new se;class jr{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new hr,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let s=!1,n=-1,i=!1,r=-1;if(typeof navigator<"u"){const a=navigator.userAgent;s=/^((?!chrome|android).)*safari/i.test(a)===!0;const o=a.match(/Version\/(\d+)/);n=s&&o?parseInt(o[1],10):-1,i=a.indexOf("Firefox")>-1,r=i?a.match(/Firefox\/([0-9]+)\./)[1]:-1}typeof createImageBitmap>"u"||s&&n<17||i&&r<98?this.textureLoader=new Ot(this.options.manager):this.textureLoader=new Gn(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new wt(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const s=this,n=this.json,i=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(r){return r._markDefs&&r._markDefs()}),Promise.all(this._invokeAll(function(r){return r.beforeRoot&&r.beforeRoot()})).then(function(){return Promise.all([s.getDependencies("scene"),s.getDependencies("animation"),s.getDependencies("camera")])}).then(function(r){const a={scene:r[0][n.scene||0],scenes:r[0],animations:r[1],cameras:r[2],asset:n.asset,parser:s,userData:{}};return Qe(i,a,n),Be(a,n),Promise.all(s._invokeAll(function(o){return o.afterRoot&&o.afterRoot(a)})).then(function(){for(const o of a.scenes)o.updateMatrixWorld();e(a)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],s=this.json.meshes||[];for(let n=0,i=t.length;n<i;n++){const r=t[n].joints;for(let a=0,o=r.length;a<o;a++)e[r[a]].isBone=!0}for(let n=0,i=e.length;n<i;n++){const r=e[n];r.mesh!==void 0&&(this._addNodeRef(this.meshCache,r.mesh),r.skin!==void 0&&(s[r.mesh].isSkinnedMesh=!0)),r.camera!==void 0&&this._addNodeRef(this.cameraCache,r.camera)}}_addNodeRef(e,t){t!==void 0&&(e.refs[t]===void 0&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,s){if(e.refs[t]<=1)return s;const n=s.clone(),i=(r,a)=>{const o=this.associations.get(r);o!=null&&this.associations.set(a,o);for(const[c,h]of r.children.entries())i(h,a.children[c])};return i(s,n),n.name+="_instance_"+e.uses[t]++,n}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let s=0;s<t.length;s++){const n=e(t[s]);if(n)return n}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const s=[];for(let n=0;n<t.length;n++){const i=e(t[n]);i&&s.push(i)}return s}getDependency(e,t){const s=e+":"+t;let n=this.cache.get(s);if(!n){switch(e){case"scene":n=this.loadScene(t);break;case"node":n=this._invokeOne(function(i){return i.loadNode&&i.loadNode(t)});break;case"mesh":n=this._invokeOne(function(i){return i.loadMesh&&i.loadMesh(t)});break;case"accessor":n=this.loadAccessor(t);break;case"bufferView":n=this._invokeOne(function(i){return i.loadBufferView&&i.loadBufferView(t)});break;case"buffer":n=this.loadBuffer(t);break;case"material":n=this._invokeOne(function(i){return i.loadMaterial&&i.loadMaterial(t)});break;case"texture":n=this._invokeOne(function(i){return i.loadTexture&&i.loadTexture(t)});break;case"skin":n=this.loadSkin(t);break;case"animation":n=this._invokeOne(function(i){return i.loadAnimation&&i.loadAnimation(t)});break;case"camera":n=this.loadCamera(t);break;default:if(n=this._invokeOne(function(i){return i!=this&&i.getDependency&&i.getDependency(e,t)}),!n)throw new Error("Unknown type: "+e);break}this.cache.add(s,n)}return n}getDependencies(e){let t=this.cache.get(e);if(!t){const s=this,n=this.json[e+(e==="mesh"?"es":"s")]||[];t=Promise.all(n.map(function(i,r){return s.getDependency(e,r)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],s=this.fileLoader;if(t.type&&t.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(t.uri===void 0&&e===0)return Promise.resolve(this.extensions[ee.KHR_BINARY_GLTF].body);const n=this.options;return new Promise(function(i,r){s.load(tt.resolveURL(t.uri,n.path),i,void 0,function(){r(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(s){const n=t.byteLength||0,i=t.byteOffset||0;return s.slice(i,i+n)})}loadAccessor(e){const t=this,s=this.json,n=this.json.accessors[e];if(n.bufferView===void 0&&n.sparse===void 0){const r=Xt[n.type],a=it[n.componentType],o=n.normalized===!0,c=new a(n.count*r);return Promise.resolve(new Oe(c,r,o))}const i=[];return n.bufferView!==void 0?i.push(this.getDependency("bufferView",n.bufferView)):i.push(null),n.sparse!==void 0&&(i.push(this.getDependency("bufferView",n.sparse.indices.bufferView)),i.push(this.getDependency("bufferView",n.sparse.values.bufferView))),Promise.all(i).then(function(r){const a=r[0],o=Xt[n.type],c=it[n.componentType],h=c.BYTES_PER_ELEMENT,l=h*o,d=n.byteOffset||0,p=n.bufferView!==void 0?s.bufferViews[n.bufferView].byteStride:void 0,w=n.normalized===!0;let x,y;if(p&&p!==l){const T=Math.floor(d/p),_="InterleavedBuffer:"+n.bufferView+":"+n.componentType+":"+T+":"+n.count;let b=t.cache.get(_);b||(x=new c(a,T*p,n.count*p/h),b=new Hn(x,p/h),t.cache.add(_,b)),y=new Zn(b,o,d%p/h,w)}else a===null?x=new c(n.count*o):x=new c(a,d,n.count*o),y=new Oe(x,o,w);if(n.sparse!==void 0){const T=Xt.SCALAR,_=it[n.sparse.indices.componentType],b=n.sparse.indices.byteOffset||0,S=n.sparse.values.byteOffset||0,P=new _(r[1],b,n.sparse.count*T),C=new c(r[2],S,n.sparse.count*o);a!==null&&(y=new Oe(y.array.slice(),y.itemSize,y.normalized)),y.normalized=!1;for(let D=0,k=P.length;D<k;D++){const B=P[D];if(y.setX(B,C[D*o]),o>=2&&y.setY(B,C[D*o+1]),o>=3&&y.setZ(B,C[D*o+2]),o>=4&&y.setW(B,C[D*o+3]),o>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}y.normalized=w}return y})}loadTexture(e){const t=this.json,s=this.options,i=t.textures[e].source,r=t.images[i];let a=this.textureLoader;if(r.uri){const o=s.manager.getHandler(r.uri);o!==null&&(a=o)}return this.loadTextureImage(e,i,a)}loadTextureImage(e,t,s){const n=this,i=this.json,r=i.textures[e],a=i.images[t],o=(a.uri||a.bufferView)+":"+r.sampler;if(this.textureCache[o])return this.textureCache[o];const c=this.loadImageSource(t,s).then(function(h){h.flipY=!1,h.name=r.name||a.name||"",h.name===""&&typeof a.uri=="string"&&a.uri.startsWith("data:image/")===!1&&(h.name=a.uri);const d=(i.samplers||{})[r.sampler]||{};return h.magFilter=Ss[d.magFilter]||ns,h.minFilter=Ss[d.minFilter]||Gs,h.wrapS=Es[d.wrapS]||je,h.wrapT=Es[d.wrapT]||je,h.generateMipmaps=!h.isCompressedTexture&&h.minFilter!==Hs&&h.minFilter!==ns,n.associations.set(h,{textures:e}),h}).catch(function(){return null});return this.textureCache[o]=c,c}loadImageSource(e,t){const s=this,n=this.json,i=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(l=>l.clone());const r=n.images[e],a=self.URL||self.webkitURL;let o=r.uri||"",c=!1;if(r.bufferView!==void 0)o=s.getDependency("bufferView",r.bufferView).then(function(l){c=!0;const d=new Blob([l],{type:r.mimeType});return o=a.createObjectURL(d),o});else if(r.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const h=Promise.resolve(o).then(function(l){return new Promise(function(d,p){let w=d;t.isImageBitmapLoader===!0&&(w=function(x){const y=new $t(x);y.needsUpdate=!0,d(y)}),t.load(tt.resolveURL(l,i.path),w,void 0,p)})}).then(function(l){return c===!0&&a.revokeObjectURL(o),Be(l,r),l.userData.mimeType=r.mimeType||Ur(r.uri),l}).catch(function(l){throw console.error("THREE.GLTFLoader: Couldn't load texture",o),l});return this.sourceCache[e]=h,h}assignTexture(e,t,s,n){const i=this;return this.getDependency("texture",s.index).then(function(r){if(!r)return null;if(s.texCoord!==void 0&&s.texCoord>0&&(r=r.clone(),r.channel=s.texCoord),i.extensions[ee.KHR_TEXTURE_TRANSFORM]){const a=s.extensions!==void 0?s.extensions[ee.KHR_TEXTURE_TRANSFORM]:void 0;if(a){const o=i.associations.get(r);r=i.extensions[ee.KHR_TEXTURE_TRANSFORM].extendTexture(r,a),i.associations.set(r,o)}}return n!==void 0&&(r.colorSpace=n),e[t]=r,r})}assignFinalMaterial(e){const t=e.geometry;let s=e.material;const n=t.attributes.tangent===void 0,i=t.attributes.color!==void 0,r=t.attributes.normal===void 0;if(e.isPoints){const a="PointsMaterial:"+s.uuid;let o=this.cache.get(a);o||(o=new Ds,Ut.prototype.copy.call(o,s),o.color.copy(s.color),o.map=s.map,o.sizeAttenuation=!1,this.cache.add(a,o)),s=o}else if(e.isLine){const a="LineBasicMaterial:"+s.uuid;let o=this.cache.get(a);o||(o=new xt,Ut.prototype.copy.call(o,s),o.color.copy(s.color),o.map=s.map,this.cache.add(a,o)),s=o}if(n||i||r){let a="ClonedMaterial:"+s.uuid+":";n&&(a+="derivative-tangents:"),i&&(a+="vertex-colors:"),r&&(a+="flat-shading:");let o=this.cache.get(a);o||(o=s.clone(),i&&(o.vertexColors=!0),r&&(o.flatShading=!0),n&&(o.normalScale&&(o.normalScale.y*=-1),o.clearcoatNormalScale&&(o.clearcoatNormalScale.y*=-1)),this.cache.add(a,o),this.associations.set(o,this.associations.get(s))),s=o}e.material=s}getMaterialType(){return Dt}loadMaterial(e){const t=this,s=this.json,n=this.extensions,i=s.materials[e];let r;const a={},o=i.extensions||{},c=[];if(o[ee.KHR_MATERIALS_UNLIT]){const l=n[ee.KHR_MATERIALS_UNLIT];r=l.getMaterialType(),c.push(l.extendParams(a,i,t))}else{const l=i.pbrMetallicRoughness||{};if(a.color=new oe(1,1,1),a.opacity=1,Array.isArray(l.baseColorFactor)){const d=l.baseColorFactor;a.color.setRGB(d[0],d[1],d[2],Ge),a.opacity=d[3]}l.baseColorTexture!==void 0&&c.push(t.assignTexture(a,"map",l.baseColorTexture,fe)),a.metalness=l.metallicFactor!==void 0?l.metallicFactor:1,a.roughness=l.roughnessFactor!==void 0?l.roughnessFactor:1,l.metallicRoughnessTexture!==void 0&&(c.push(t.assignTexture(a,"metalnessMap",l.metallicRoughnessTexture)),c.push(t.assignTexture(a,"roughnessMap",l.metallicRoughnessTexture))),r=this._invokeOne(function(d){return d.getMaterialType&&d.getMaterialType(e)}),c.push(Promise.all(this._invokeAll(function(d){return d.extendMaterialParams&&d.extendMaterialParams(e,a)})))}i.doubleSided===!0&&(a.side=cs);const h=i.alphaMode||Kt.OPAQUE;if(h===Kt.BLEND?(a.transparent=!0,a.depthWrite=!1):(a.transparent=!1,h===Kt.MASK&&(a.alphaTest=i.alphaCutoff!==void 0?i.alphaCutoff:.5)),i.normalTexture!==void 0&&r!==De&&(c.push(t.assignTexture(a,"normalMap",i.normalTexture)),a.normalScale=new Z(1,1),i.normalTexture.scale!==void 0)){const l=i.normalTexture.scale;a.normalScale.set(l,l)}if(i.occlusionTexture!==void 0&&r!==De&&(c.push(t.assignTexture(a,"aoMap",i.occlusionTexture)),i.occlusionTexture.strength!==void 0&&(a.aoMapIntensity=i.occlusionTexture.strength)),i.emissiveFactor!==void 0&&r!==De){const l=i.emissiveFactor;a.emissive=new oe().setRGB(l[0],l[1],l[2],Ge)}return i.emissiveTexture!==void 0&&r!==De&&c.push(t.assignTexture(a,"emissiveMap",i.emissiveTexture,fe)),Promise.all(c).then(function(){const l=new r(a);return i.name&&(l.name=i.name),Be(l,i),t.associations.set(l,{materials:e}),i.extensions&&Qe(n,l,i),l})}createUniqueName(e){const t=ut.sanitizeNodeName(e||"");return t in this.nodeNamesUsed?t+"_"+ ++this.nodeNamesUsed[t]:(this.nodeNamesUsed[t]=0,t)}loadGeometries(e){const t=this,s=this.extensions,n=this.primitiveCache;function i(a){return s[ee.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a,t).then(function(o){return _s(o,a,t)})}const r=[];for(let a=0,o=e.length;a<o;a++){const c=e[a],h=Vr(c),l=n[h];if(l)r.push(l.promise);else{let d;c.extensions&&c.extensions[ee.KHR_DRACO_MESH_COMPRESSION]?d=i(c):d=_s(new ze,c,t),n[h]={primitive:c,promise:d},r.push(d)}}return Promise.all(r)}loadMesh(e){const t=this,s=this.json,n=this.extensions,i=s.meshes[e],r=i.primitives,a=[];for(let o=0,c=r.length;o<c;o++){const h=r[o].material===void 0?Fr(this.cache):this.getDependency("material",r[o].material);a.push(h)}return a.push(t.loadGeometries(r)),Promise.all(a).then(function(o){const c=o.slice(0,o.length-1),h=o[o.length-1],l=[];for(let p=0,w=h.length;p<w;p++){const x=h[p],y=r[p];let T;const _=c[p];if(y.mode===ve.TRIANGLES||y.mode===ve.TRIANGLE_STRIP||y.mode===ve.TRIANGLE_FAN||y.mode===void 0)T=i.isSkinnedMesh===!0?new Ns(x,_):new Ae(x,_),T.isSkinnedMesh===!0&&T.normalizeSkinWeights(),y.mode===ve.TRIANGLE_STRIP?T.geometry=vs(T.geometry,js):y.mode===ve.TRIANGLE_FAN&&(T.geometry=vs(T.geometry,ss));else if(y.mode===ve.LINES)T=new Os(x,_);else if(y.mode===ve.LINE_STRIP)T=new It(x,_);else if(y.mode===ve.LINE_LOOP)T=new Yn(x,_);else if(y.mode===ve.POINTS)T=new ks(x,_);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+y.mode);Object.keys(T.geometry.morphAttributes).length>0&&Br(T,i),T.name=t.createUniqueName(i.name||"mesh_"+e),Be(T,i),y.extensions&&Qe(n,T,y),t.assignFinalMaterial(T),l.push(T)}for(let p=0,w=l.length;p<w;p++)t.associations.set(l[p],{meshes:e,primitives:p});if(l.length===1)return i.extensions&&Qe(n,l[0],i),l[0];const d=new st;i.extensions&&Qe(n,d,i),t.associations.set(d,{meshes:e});for(let p=0,w=l.length;p<w;p++)d.add(l[p]);return d})}loadCamera(e){let t;const s=this.json.cameras[e],n=s[s.type];if(!n){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return s.type==="perspective"?t=new yt(me.radToDeg(n.yfov),n.aspectRatio||1,n.znear||1,n.zfar||2e6):s.type==="orthographic"&&(t=new Ls(-n.xmag,n.xmag,n.ymag,-n.ymag,n.znear,n.zfar)),s.name&&(t.name=this.createUniqueName(s.name)),Be(t,s),Promise.resolve(t)}loadSkin(e){const t=this.json.skins[e],s=[];for(let n=0,i=t.joints.length;n<i;n++)s.push(this._loadNodeShallow(t.joints[n]));return t.inverseBindMatrices!==void 0?s.push(this.getDependency("accessor",t.inverseBindMatrices)):s.push(null),Promise.all(s).then(function(n){const i=n.pop(),r=n,a=[],o=[];for(let c=0,h=r.length;c<h;c++){const l=r[c];if(l){a.push(l);const d=new se;i!==null&&d.fromArray(i.array,c*16),o.push(d)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[c])}return new Bs(a,o)})}loadAnimation(e){const t=this.json,s=this,n=t.animations[e],i=n.name?n.name:"animation_"+e,r=[],a=[],o=[],c=[],h=[];for(let l=0,d=n.channels.length;l<d;l++){const p=n.channels[l],w=n.samplers[p.sampler],x=p.target,y=x.node,T=n.parameters!==void 0?n.parameters[w.input]:w.input,_=n.parameters!==void 0?n.parameters[w.output]:w.output;x.node!==void 0&&(r.push(this.getDependency("node",y)),a.push(this.getDependency("accessor",T)),o.push(this.getDependency("accessor",_)),c.push(w),h.push(x))}return Promise.all([Promise.all(r),Promise.all(a),Promise.all(o),Promise.all(c),Promise.all(h)]).then(function(l){const d=l[0],p=l[1],w=l[2],x=l[3],y=l[4],T=[];for(let _=0,b=d.length;_<b;_++){const S=d[_],P=p[_],C=w[_],D=x[_],k=y[_];if(S===void 0)continue;S.updateMatrix&&S.updateMatrix();const B=s._createAnimationTracks(S,P,C,D,k);if(B)for(let O=0;O<B.length;O++)T.push(B[O])}return new zs(i,void 0,T)})}createNodeMesh(e){const t=this.json,s=this,n=t.nodes[e];return n.mesh===void 0?null:s.getDependency("mesh",n.mesh).then(function(i){const r=s._getNodeRef(s.meshCache,n.mesh,i);return n.weights!==void 0&&r.traverse(function(a){if(a.isMesh)for(let o=0,c=n.weights.length;o<c;o++)a.morphTargetInfluences[o]=n.weights[o]}),r})}loadNode(e){const t=this.json,s=this,n=t.nodes[e],i=s._loadNodeShallow(e),r=[],a=n.children||[];for(let c=0,h=a.length;c<h;c++)r.push(s.getDependency("node",a[c]));const o=n.skin===void 0?Promise.resolve(null):s.getDependency("skin",n.skin);return Promise.all([i,Promise.all(r),o]).then(function(c){const h=c[0],l=c[1],d=c[2];d!==null&&h.traverse(function(p){p.isSkinnedMesh&&p.bind(d,zr)});for(let p=0,w=l.length;p<w;p++)h.add(l[p]);return h})}_loadNodeShallow(e){const t=this.json,s=this.extensions,n=this;if(this.nodeCache[e]!==void 0)return this.nodeCache[e];const i=t.nodes[e],r=i.name?n.createUniqueName(i.name):"",a=[],o=n._invokeOne(function(c){return c.createNodeMesh&&c.createNodeMesh(e)});return o&&a.push(o),i.camera!==void 0&&a.push(n.getDependency("camera",i.camera).then(function(c){return n._getNodeRef(n.cameraCache,i.camera,c)})),n._invokeAll(function(c){return c.createNodeAttachment&&c.createNodeAttachment(e)}).forEach(function(c){a.push(c)}),this.nodeCache[e]=Promise.all(a).then(function(c){let h;if(i.isBone===!0?h=new Jt:c.length>1?h=new st:c.length===1?h=c[0]:h=new Ue,h!==c[0])for(let l=0,d=c.length;l<d;l++)h.add(c[l]);if(i.name&&(h.userData.name=i.name,h.name=r),Be(h,i),i.extensions&&Qe(s,h,i),i.matrix!==void 0){const l=new se;l.fromArray(i.matrix),h.applyMatrix4(l)}else i.translation!==void 0&&h.position.fromArray(i.translation),i.rotation!==void 0&&h.quaternion.fromArray(i.rotation),i.scale!==void 0&&h.scale.fromArray(i.scale);return n.associations.has(h)||n.associations.set(h,{}),n.associations.get(h).nodes=e,h}),this.nodeCache[e]}loadScene(e){const t=this.extensions,s=this.json.scenes[e],n=this,i=new st;s.name&&(i.name=n.createUniqueName(s.name)),Be(i,s),s.extensions&&Qe(t,i,s);const r=s.nodes||[],a=[];for(let o=0,c=r.length;o<c;o++)a.push(n.getDependency("node",r[o]));return Promise.all(a).then(function(o){for(let h=0,l=o.length;h<l;h++)i.add(o[h]);const c=h=>{const l=new Map;for(const[d,p]of n.associations)(d instanceof Ut||d instanceof $t)&&l.set(d,p);return h.traverse(d=>{const p=n.associations.get(d);p!=null&&l.set(d,p)}),l};return n.associations=c(i),i})}_createAnimationTracks(e,t,s,n,i){const r=[],a=e.name?e.name:e.uuid,o=[];Xe[i.path]===Xe.weights?e.traverse(function(d){d.morphTargetInfluences&&o.push(d.name?d.name:d.uuid)}):o.push(a);let c;switch(Xe[i.path]){case Xe.weights:c=ts;break;case Xe.rotation:c=Pt;break;case Xe.position:case Xe.scale:c=es;break;default:switch(s.itemSize){case 1:c=ts;break;case 2:case 3:default:c=es;break}break}const h=n.interpolation!==void 0?Or[n.interpolation]:Ws,l=this._getArrayFromAccessor(s);for(let d=0,p=o.length;d<p;d++){const w=new c(o[d]+"."+Xe[i.path],t.array,l,h);n.interpolation==="CUBICSPLINE"&&this._createCubicSplineTrackInterpolant(w),r.push(w)}return r}_getArrayFromAccessor(e){let t=e.array;if(e.normalized){const s=os(t.constructor),n=new Float32Array(t.length);for(let i=0,r=t.length;i<r;i++)n[i]=t[i]*s;t=n}return t}_createCubicSplineTrackInterpolant(e){e.createInterpolant=function(s){const n=this instanceof Pt?Dr:hn;return new n(this.times,this.values,this.getValueSize()/3,s)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function Gr(u,e,t){const s=e.attributes,n=new Ze;if(s.POSITION!==void 0){const a=t.json.accessors[s.POSITION],o=a.min,c=a.max;if(o!==void 0&&c!==void 0){if(n.set(new G(o[0],o[1],o[2]),new G(c[0],c[1],c[2])),a.normalized){const h=os(it[a.componentType]);n.min.multiplyScalar(h),n.max.multiplyScalar(h)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const i=e.targets;if(i!==void 0){const a=new G,o=new G;for(let c=0,h=i.length;c<h;c++){const l=i[c];if(l.POSITION!==void 0){const d=t.json.accessors[l.POSITION],p=d.min,w=d.max;if(p!==void 0&&w!==void 0){if(o.setX(Math.max(Math.abs(p[0]),Math.abs(w[0]))),o.setY(Math.max(Math.abs(p[1]),Math.abs(w[1]))),o.setZ(Math.max(Math.abs(p[2]),Math.abs(w[2]))),d.normalized){const x=os(it[d.componentType]);o.multiplyScalar(x)}a.max(o)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}n.expandByVector(a)}u.boundingBox=n;const r=new ei;n.getCenter(r.center),r.radius=n.min.distanceTo(n.max)/2,u.boundingSphere=r}function _s(u,e,t){const s=e.attributes,n=[];function i(r,a){return t.getDependency("accessor",r).then(function(o){u.setAttribute(a,o)})}for(const r in s){const a=rs[r]||r.toLowerCase();a in u.attributes||n.push(i(s[r],a))}if(e.indices!==void 0&&!u.index){const r=t.getDependency("accessor",e.indices).then(function(a){u.setIndex(a)});n.push(r)}return Ie.workingColorSpace!==Ge&&"COLOR_0"in s&&console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Ie.workingColorSpace}" not supported.`),Be(u,e),Gr(u,e,t),Promise.all(n).then(function(){return e.targets!==void 0?Nr(u,e.targets,t):u})}const Hr=fe;class ft extends ht{constructor(e){super(e),this.defaultDPI=90,this.defaultUnit="px"}load(e,t,s,n){const i=this,r=new wt(i.manager);r.setPath(i.path),r.setRequestHeader(i.requestHeader),r.setWithCredentials(i.withCredentials),r.load(e,function(a){try{t(i.parse(a))}catch(o){n?n(o):console.error(o),i.manager.itemError(e)}},s,n)}parse(e){const t=this;function s(E,A){if(E.nodeType!==1)return;const m=S(E);let f=!1,L=null;switch(E.nodeName){case"svg":A=w(E,A);break;case"style":i(E);break;case"g":A=w(E,A);break;case"path":A=w(E,A),E.hasAttribute("d")&&(L=n(E));break;case"rect":A=w(E,A),L=o(E);break;case"polygon":A=w(E,A),L=c(E);break;case"polyline":A=w(E,A),L=h(E);break;case"circle":A=w(E,A),L=l(E);break;case"ellipse":A=w(E,A),L=d(E);break;case"line":A=w(E,A),L=p(E);break;case"defs":f=!0;break;case"use":A=w(E,A);const z=(E.getAttributeNS("http://www.w3.org/1999/xlink","href")||"").substring(1),H=E.viewportElement.getElementById(z);H?s(H,A):console.warn("SVGLoader: 'use node' references non-existent node id: "+z);break}L&&(A.fill!==void 0&&A.fill!=="none"&&L.color.setStyle(A.fill,Hr),C(L,be),j.push(L),L.userData={node:E,style:A});const V=E.childNodes;for(let R=0;R<V.length;R++){const z=V[R];f&&z.nodeName!=="style"&&z.nodeName!=="defs"||s(z,A)}m&&(Y.pop(),Y.length>0?be.copy(Y[Y.length-1]):be.identity())}function n(E){const A=new Ye,m=new Z,f=new Z,L=new Z;let V=!0,R=!1;const z=E.getAttribute("d");if(z===""||z==="none")return null;const H=z.match(/[a-df-z][^a-df-z]*/ig);for(let W=0,I=H.length;W<I;W++){const N=H[W],X=N.charAt(0),K=N.slice(1).trim();V===!0&&(R=!0,V=!1);let M;switch(X){case"M":M=y(K);for(let g=0,q=M.length;g<q;g+=2)m.x=M[g+0],m.y=M[g+1],f.x=m.x,f.y=m.y,g===0?A.moveTo(m.x,m.y):A.lineTo(m.x,m.y),g===0&&L.copy(m);break;case"H":M=y(K);for(let g=0,q=M.length;g<q;g++)m.x=M[g],f.x=m.x,f.y=m.y,A.lineTo(m.x,m.y),g===0&&R===!0&&L.copy(m);break;case"V":M=y(K);for(let g=0,q=M.length;g<q;g++)m.y=M[g],f.x=m.x,f.y=m.y,A.lineTo(m.x,m.y),g===0&&R===!0&&L.copy(m);break;case"L":M=y(K);for(let g=0,q=M.length;g<q;g+=2)m.x=M[g+0],m.y=M[g+1],f.x=m.x,f.y=m.y,A.lineTo(m.x,m.y),g===0&&R===!0&&L.copy(m);break;case"C":M=y(K);for(let g=0,q=M.length;g<q;g+=6)A.bezierCurveTo(M[g+0],M[g+1],M[g+2],M[g+3],M[g+4],M[g+5]),f.x=M[g+2],f.y=M[g+3],m.x=M[g+4],m.y=M[g+5],g===0&&R===!0&&L.copy(m);break;case"S":M=y(K);for(let g=0,q=M.length;g<q;g+=4)A.bezierCurveTo(x(m.x,f.x),x(m.y,f.y),M[g+0],M[g+1],M[g+2],M[g+3]),f.x=M[g+0],f.y=M[g+1],m.x=M[g+2],m.y=M[g+3],g===0&&R===!0&&L.copy(m);break;case"Q":M=y(K);for(let g=0,q=M.length;g<q;g+=4)A.quadraticCurveTo(M[g+0],M[g+1],M[g+2],M[g+3]),f.x=M[g+0],f.y=M[g+1],m.x=M[g+2],m.y=M[g+3],g===0&&R===!0&&L.copy(m);break;case"T":M=y(K);for(let g=0,q=M.length;g<q;g+=2){const ne=x(m.x,f.x),Te=x(m.y,f.y);A.quadraticCurveTo(ne,Te,M[g+0],M[g+1]),f.x=ne,f.y=Te,m.x=M[g+0],m.y=M[g+1],g===0&&R===!0&&L.copy(m)}break;case"A":M=y(K,[3,4],7);for(let g=0,q=M.length;g<q;g+=7){if(M[g+5]==m.x&&M[g+6]==m.y)continue;const ne=m.clone();m.x=M[g+5],m.y=M[g+6],f.x=m.x,f.y=m.y,r(A,M[g],M[g+1],M[g+2],M[g+3],M[g+4],ne,m),g===0&&R===!0&&L.copy(m)}break;case"m":M=y(K);for(let g=0,q=M.length;g<q;g+=2)m.x+=M[g+0],m.y+=M[g+1],f.x=m.x,f.y=m.y,g===0?A.moveTo(m.x,m.y):A.lineTo(m.x,m.y),g===0&&L.copy(m);break;case"h":M=y(K);for(let g=0,q=M.length;g<q;g++)m.x+=M[g],f.x=m.x,f.y=m.y,A.lineTo(m.x,m.y),g===0&&R===!0&&L.copy(m);break;case"v":M=y(K);for(let g=0,q=M.length;g<q;g++)m.y+=M[g],f.x=m.x,f.y=m.y,A.lineTo(m.x,m.y),g===0&&R===!0&&L.copy(m);break;case"l":M=y(K);for(let g=0,q=M.length;g<q;g+=2)m.x+=M[g+0],m.y+=M[g+1],f.x=m.x,f.y=m.y,A.lineTo(m.x,m.y),g===0&&R===!0&&L.copy(m);break;case"c":M=y(K);for(let g=0,q=M.length;g<q;g+=6)A.bezierCurveTo(m.x+M[g+0],m.y+M[g+1],m.x+M[g+2],m.y+M[g+3],m.x+M[g+4],m.y+M[g+5]),f.x=m.x+M[g+2],f.y=m.y+M[g+3],m.x+=M[g+4],m.y+=M[g+5],g===0&&R===!0&&L.copy(m);break;case"s":M=y(K);for(let g=0,q=M.length;g<q;g+=4)A.bezierCurveTo(x(m.x,f.x),x(m.y,f.y),m.x+M[g+0],m.y+M[g+1],m.x+M[g+2],m.y+M[g+3]),f.x=m.x+M[g+0],f.y=m.y+M[g+1],m.x+=M[g+2],m.y+=M[g+3],g===0&&R===!0&&L.copy(m);break;case"q":M=y(K);for(let g=0,q=M.length;g<q;g+=4)A.quadraticCurveTo(m.x+M[g+0],m.y+M[g+1],m.x+M[g+2],m.y+M[g+3]),f.x=m.x+M[g+0],f.y=m.y+M[g+1],m.x+=M[g+2],m.y+=M[g+3],g===0&&R===!0&&L.copy(m);break;case"t":M=y(K);for(let g=0,q=M.length;g<q;g+=2){const ne=x(m.x,f.x),Te=x(m.y,f.y);A.quadraticCurveTo(ne,Te,m.x+M[g+0],m.y+M[g+1]),f.x=ne,f.y=Te,m.x=m.x+M[g+0],m.y=m.y+M[g+1],g===0&&R===!0&&L.copy(m)}break;case"a":M=y(K,[3,4],7);for(let g=0,q=M.length;g<q;g+=7){if(M[g+5]==0&&M[g+6]==0)continue;const ne=m.clone();m.x+=M[g+5],m.y+=M[g+6],f.x=m.x,f.y=m.y,r(A,M[g],M[g+1],M[g+2],M[g+3],M[g+4],ne,m),g===0&&R===!0&&L.copy(m)}break;case"Z":case"z":A.currentPath.autoClose=!0,A.currentPath.curves.length>0&&(m.copy(L),A.currentPath.currentPoint.copy(m),V=!0);break;default:console.warn(N)}R=!1}return A}function i(E){if(!(!E.sheet||!E.sheet.cssRules||!E.sheet.cssRules.length))for(let A=0;A<E.sheet.cssRules.length;A++){const m=E.sheet.cssRules[A];if(m.type!==1)continue;const f=m.selectorText.split(/,/gm).filter(Boolean).map(L=>L.trim());for(let L=0;L<f.length;L++){const V=Object.fromEntries(Object.entries(m.style).filter(([,R])=>R!==""));$[f[L]]=Object.assign($[f[L]]||{},V)}}}function r(E,A,m,f,L,V,R,z){if(A==0||m==0){E.lineTo(z.x,z.y);return}f=f*Math.PI/180,A=Math.abs(A),m=Math.abs(m);const H=(R.x-z.x)/2,W=(R.y-z.y)/2,I=Math.cos(f)*H+Math.sin(f)*W,N=-Math.sin(f)*H+Math.cos(f)*W;let X=A*A,K=m*m;const M=I*I,g=N*N,q=M/X+g/K;if(q>1){const vt=Math.sqrt(q);A=vt*A,m=vt*m,X=A*A,K=m*m}const ne=X*g+K*M,Te=(X*K-ne)/ne;let Le=Math.sqrt(Math.max(0,Te));L===V&&(Le=-Le);const ye=Le*A*N/m,He=-Le*m*I/A,At=Math.cos(f)*ye-Math.sin(f)*He+(R.x+z.x)/2,ps=Math.sin(f)*ye+Math.cos(f)*He+(R.y+z.y)/2,Tt=a(1,0,(I-ye)/A,(N-He)/m),Bt=a((I-ye)/A,(N-He)/m,(-I-ye)/A,(-N-He)/m)%(Math.PI*2);E.currentPath.absellipse(At,ps,A,m,Tt,Tt+Bt,V===0,f)}function a(E,A,m,f){const L=E*m+A*f,V=Math.sqrt(E*E+A*A)*Math.sqrt(m*m+f*f);let R=Math.acos(Math.max(-1,Math.min(1,L/V)));return E*f-A*m<0&&(R=-R),R}function o(E){const A=b(E.getAttribute("x")||0),m=b(E.getAttribute("y")||0),f=b(E.getAttribute("rx")||E.getAttribute("ry")||0),L=b(E.getAttribute("ry")||E.getAttribute("rx")||0),V=b(E.getAttribute("width")),R=b(E.getAttribute("height")),z=1-.551915024494,H=new Ye;return H.moveTo(A+f,m),H.lineTo(A+V-f,m),(f!==0||L!==0)&&H.bezierCurveTo(A+V-f*z,m,A+V,m+L*z,A+V,m+L),H.lineTo(A+V,m+R-L),(f!==0||L!==0)&&H.bezierCurveTo(A+V,m+R-L*z,A+V-f*z,m+R,A+V-f,m+R),H.lineTo(A+f,m+R),(f!==0||L!==0)&&H.bezierCurveTo(A+f*z,m+R,A,m+R-L*z,A,m+R-L),H.lineTo(A,m+L),(f!==0||L!==0)&&H.bezierCurveTo(A,m+L*z,A+f*z,m,A+f,m),H}function c(E){function A(V,R,z){const H=b(R),W=b(z);L===0?f.moveTo(H,W):f.lineTo(H,W),L++}const m=/([+-]?\d*\.?\d+(?:e[+-]?\d+)?)(?:,|\s)([+-]?\d*\.?\d+(?:e[+-]?\d+)?)/g,f=new Ye;let L=0;return E.getAttribute("points").replace(m,A),f.currentPath.autoClose=!0,f}function h(E){function A(V,R,z){const H=b(R),W=b(z);L===0?f.moveTo(H,W):f.lineTo(H,W),L++}const m=/([+-]?\d*\.?\d+(?:e[+-]?\d+)?)(?:,|\s)([+-]?\d*\.?\d+(?:e[+-]?\d+)?)/g,f=new Ye;let L=0;return E.getAttribute("points").replace(m,A),f.currentPath.autoClose=!1,f}function l(E){const A=b(E.getAttribute("cx")||0),m=b(E.getAttribute("cy")||0),f=b(E.getAttribute("r")||0),L=new zt;L.absarc(A,m,f,0,Math.PI*2);const V=new Ye;return V.subPaths.push(L),V}function d(E){const A=b(E.getAttribute("cx")||0),m=b(E.getAttribute("cy")||0),f=b(E.getAttribute("rx")||0),L=b(E.getAttribute("ry")||0),V=new zt;V.absellipse(A,m,f,L,0,Math.PI*2);const R=new Ye;return R.subPaths.push(V),R}function p(E){const A=b(E.getAttribute("x1")||0),m=b(E.getAttribute("y1")||0),f=b(E.getAttribute("x2")||0),L=b(E.getAttribute("y2")||0),V=new Ye;return V.moveTo(A,m),V.lineTo(f,L),V.currentPath.autoClose=!1,V}function w(E,A){A=Object.assign({},A);let m={};if(E.hasAttribute("class")){const R=E.getAttribute("class").split(/\s/).filter(Boolean).map(z=>z.trim());for(let z=0;z<R.length;z++)m=Object.assign(m,$["."+R[z]])}E.hasAttribute("id")&&(m=Object.assign(m,$["#"+E.getAttribute("id")]));function f(R,z,H){H===void 0&&(H=function(I){return I.startsWith("url")&&console.warn("SVGLoader: url access in attributes is not implemented."),I}),E.hasAttribute(R)&&(A[z]=H(E.getAttribute(R))),m[R]&&(A[z]=H(m[R])),E.style&&E.style[R]!==""&&(A[z]=H(E.style[R]))}function L(R){return Math.max(0,Math.min(1,b(R)))}function V(R){return Math.max(0,b(R))}return f("fill","fill"),f("fill-opacity","fillOpacity",L),f("fill-rule","fillRule"),f("opacity","opacity",L),f("stroke","stroke"),f("stroke-opacity","strokeOpacity",L),f("stroke-width","strokeWidth",V),f("stroke-linejoin","strokeLineJoin"),f("stroke-linecap","strokeLineCap"),f("stroke-miterlimit","strokeMiterLimit",V),f("visibility","visibility"),A}function x(E,A){return E-(A-E)}function y(E,A,m){if(typeof E!="string")throw new TypeError("Invalid input: "+typeof E);const f={WHITESPACE:/[ \t\r\n]/,DIGIT:/[\d]/,SIGN:/[-+]/,POINT:/\./,COMMA:/,/,EXP:/e/i,FLAGS:/[01]/},L=0,V=1,R=2,z=3;let H=L,W=!0,I="",N="";const X=[];function K(ne,Te,Le){const ye=new SyntaxError('Unexpected character "'+ne+'" at index '+Te+".");throw ye.partial=Le,ye}function M(){I!==""&&(N===""?X.push(Number(I)):X.push(Number(I)*Math.pow(10,Number(N)))),I="",N=""}let g;const q=E.length;for(let ne=0;ne<q;ne++){if(g=E[ne],Array.isArray(A)&&A.includes(X.length%m)&&f.FLAGS.test(g)){H=V,I=g,M();continue}if(H===L){if(f.WHITESPACE.test(g))continue;if(f.DIGIT.test(g)||f.SIGN.test(g)){H=V,I=g;continue}if(f.POINT.test(g)){H=R,I=g;continue}f.COMMA.test(g)&&(W&&K(g,ne,X),W=!0)}if(H===V){if(f.DIGIT.test(g)){I+=g;continue}if(f.POINT.test(g)){I+=g,H=R;continue}if(f.EXP.test(g)){H=z;continue}f.SIGN.test(g)&&I.length===1&&f.SIGN.test(I[0])&&K(g,ne,X)}if(H===R){if(f.DIGIT.test(g)){I+=g;continue}if(f.EXP.test(g)){H=z;continue}f.POINT.test(g)&&I[I.length-1]==="."&&K(g,ne,X)}if(H===z){if(f.DIGIT.test(g)){N+=g;continue}if(f.SIGN.test(g)){if(N===""){N+=g;continue}N.length===1&&f.SIGN.test(N)&&K(g,ne,X)}}f.WHITESPACE.test(g)?(M(),H=L,W=!1):f.COMMA.test(g)?(M(),H=L,W=!0):f.SIGN.test(g)?(M(),H=V,I=g):f.POINT.test(g)?(M(),H=R,I=g):K(g,ne,X)}return M(),X}const T=["mm","cm","in","pt","pc","px"],_={mm:{mm:1,cm:.1,in:1/25.4,pt:72/25.4,pc:6/25.4,px:-1},cm:{mm:10,cm:1,in:1/2.54,pt:72/2.54,pc:6/2.54,px:-1},in:{mm:25.4,cm:2.54,in:1,pt:72,pc:6,px:-1},pt:{mm:25.4/72,cm:2.54/72,in:1/72,pt:1,pc:6/72,px:-1},pc:{mm:25.4/6,cm:2.54/6,in:1/6,pt:72/6,pc:1,px:-1},px:{px:1}};function b(E){let A="px";if(typeof E=="string"||E instanceof String)for(let f=0,L=T.length;f<L;f++){const V=T[f];if(E.endsWith(V)){A=V,E=E.substring(0,E.length-V.length);break}}let m;return A==="px"&&t.defaultUnit!=="px"?m=_.in[t.defaultUnit]/t.defaultDPI:(m=_[A][t.defaultUnit],m<0&&(m=_[A].in*t.defaultDPI)),m*parseFloat(E)}function S(E){if(!(E.hasAttribute("transform")||E.nodeName==="use"&&(E.hasAttribute("x")||E.hasAttribute("y"))))return null;const A=P(E);return Y.length>0&&A.premultiply(Y[Y.length-1]),be.copy(A),Y.push(A),A}function P(E){const A=new Ke,m=te;if(E.nodeName==="use"&&(E.hasAttribute("x")||E.hasAttribute("y"))){const f=b(E.getAttribute("x")),L=b(E.getAttribute("y"));A.translate(f,L)}if(E.hasAttribute("transform")){const f=E.getAttribute("transform").split(")");for(let L=f.length-1;L>=0;L--){const V=f[L].trim();if(V==="")continue;const R=V.indexOf("("),z=V.length;if(R>0&&R<z){const H=V.slice(0,R),W=y(V.slice(R+1));switch(m.identity(),H){case"translate":if(W.length>=1){const I=W[0];let N=0;W.length>=2&&(N=W[1]),m.translate(I,N)}break;case"rotate":if(W.length>=1){let I=0,N=0,X=0;I=W[0]*Math.PI/180,W.length>=3&&(N=W[1],X=W[2]),ie.makeTranslation(-N,-X),Q.makeRotation(I),F.multiplyMatrices(Q,ie),ie.makeTranslation(N,X),m.multiplyMatrices(ie,F)}break;case"scale":if(W.length>=1){const I=W[0];let N=I;W.length>=2&&(N=W[1]),m.scale(I,N)}break;case"skewX":W.length===1&&m.set(1,Math.tan(W[0]*Math.PI/180),0,0,1,0,0,0,1);break;case"skewY":W.length===1&&m.set(1,0,0,Math.tan(W[0]*Math.PI/180),1,0,0,0,1);break;case"matrix":W.length===6&&m.set(W[0],W[2],W[4],W[1],W[3],W[5],0,0,1);break}}A.premultiply(m)}}return A}function C(E,A){function m(R){le.set(R.x,R.y,1).applyMatrix3(A),R.set(le.x,le.y)}function f(R){const z=R.xRadius,H=R.yRadius,W=Math.cos(R.aRotation),I=Math.sin(R.aRotation),N=new G(z*W,z*I,0),X=new G(-H*I,H*W,0),K=N.applyMatrix3(A),M=X.applyMatrix3(A),g=te.set(K.x,M.x,0,K.y,M.y,0,0,0,1),q=ie.copy(g).invert(),Le=Q.copy(q).transpose().multiply(q).elements,ye=U(Le[0],Le[1],Le[4]),He=Math.sqrt(ye.rt1),At=Math.sqrt(ye.rt2);if(R.xRadius=1/He,R.yRadius=1/At,R.aRotation=Math.atan2(ye.sn,ye.cs),!((R.aEndAngle-R.aStartAngle)%(2*Math.PI)<Number.EPSILON)){const Tt=ie.set(He,0,0,0,At,0,0,0,1),Bt=Q.set(ye.cs,ye.sn,0,-ye.sn,ye.cs,0,0,0,1),vt=Tt.multiply(Bt).multiply(g),fs=ms=>{const{x:pn,y:fn}=new G(Math.cos(ms),Math.sin(ms),0).applyMatrix3(vt);return Math.atan2(fn,pn)};R.aStartAngle=fs(R.aStartAngle),R.aEndAngle=fs(R.aEndAngle),D(A)&&(R.aClockwise=!R.aClockwise)}}function L(R){const z=B(A),H=O(A);R.xRadius*=z,R.yRadius*=H;const W=z>Number.EPSILON?Math.atan2(A.elements[1],A.elements[0]):Math.atan2(-A.elements[3],A.elements[4]);R.aRotation+=W,D(A)&&(R.aStartAngle*=-1,R.aEndAngle*=-1,R.aClockwise=!R.aClockwise)}const V=E.subPaths;for(let R=0,z=V.length;R<z;R++){const W=V[R].curves;for(let I=0;I<W.length;I++){const N=W[I];N.isLineCurve?(m(N.v1),m(N.v2)):N.isCubicBezierCurve?(m(N.v0),m(N.v1),m(N.v2),m(N.v3)):N.isQuadraticBezierCurve?(m(N.v0),m(N.v1),m(N.v2)):N.isEllipseCurve&&(re.set(N.aX,N.aY),m(re),N.aX=re.x,N.aY=re.y,k(A)?f(N):L(N))}}}function D(E){const A=E.elements;return A[0]*A[4]-A[1]*A[3]<0}function k(E){const A=E.elements,m=A[0]*A[3]+A[1]*A[4];if(m===0)return!1;const f=B(E),L=O(E);return Math.abs(m/(f*L))>Number.EPSILON}function B(E){const A=E.elements;return Math.sqrt(A[0]*A[0]+A[1]*A[1])}function O(E){const A=E.elements;return Math.sqrt(A[3]*A[3]+A[4]*A[4])}function U(E,A,m){let f,L,V,R,z;const H=E+m,W=E-m,I=Math.sqrt(W*W+4*A*A);return H>0?(f=.5*(H+I),z=1/f,L=E*z*m-A*z*A):H<0?L=.5*(H-I):(f=.5*I,L=-.5*I),W>0?V=W+I:V=W-I,Math.abs(V)>2*Math.abs(A)?(z=-2*A/V,R=1/Math.sqrt(1+z*z),V=z*R):Math.abs(A)===0?(V=1,R=0):(z=-.5*V/A,V=1/Math.sqrt(1+z*z),R=z*V),W>0&&(z=V,V=-R,R=z),{rt1:f,rt2:L,cs:V,sn:R}}const j=[],$={},Y=[],te=new Ke,ie=new Ke,Q=new Ke,F=new Ke,re=new Z,le=new G,be=new Ke,Se=new DOMParser().parseFromString(e,"image/svg+xml");return s(Se.documentElement,{fill:"#000",fillOpacity:1,strokeOpacity:1,strokeWidth:1,strokeLineJoin:"miter",strokeLineCap:"butt",strokeMiterLimit:4}),{paths:j,xml:Se.documentElement}}static createShapes(e){const s={ORIGIN:0,DESTINATION:1,BETWEEN:2,LEFT:3,RIGHT:4,BEHIND:5,BEYOND:6},n={loc:s.ORIGIN,t:0};function i(x,y,T,_){const b=x.x,S=y.x,P=T.x,C=_.x,D=x.y,k=y.y,B=T.y,O=_.y,U=(C-P)*(D-B)-(O-B)*(b-P),j=(S-b)*(D-B)-(k-D)*(b-P),$=(O-B)*(S-b)-(C-P)*(k-D),Y=U/$,te=j/$;if($===0&&U!==0||Y<=0||Y>=1||te<0||te>1)return null;if(U===0&&$===0){for(let ie=0;ie<2;ie++)if(r(ie===0?T:_,x,y),n.loc==s.ORIGIN){const Q=ie===0?T:_;return{x:Q.x,y:Q.y,t:n.t}}else if(n.loc==s.BETWEEN){const Q=+(b+n.t*(S-b)).toPrecision(10),F=+(D+n.t*(k-D)).toPrecision(10);return{x:Q,y:F,t:n.t}}return null}else{for(let F=0;F<2;F++)if(r(F===0?T:_,x,y),n.loc==s.ORIGIN){const re=F===0?T:_;return{x:re.x,y:re.y,t:n.t}}const ie=+(b+Y*(S-b)).toPrecision(10),Q=+(D+Y*(k-D)).toPrecision(10);return{x:ie,y:Q,t:Y}}}function r(x,y,T){const _=T.x-y.x,b=T.y-y.y,S=x.x-y.x,P=x.y-y.y,C=_*P-S*b;if(x.x===y.x&&x.y===y.y){n.loc=s.ORIGIN,n.t=0;return}if(x.x===T.x&&x.y===T.y){n.loc=s.DESTINATION,n.t=1;return}if(C<-Number.EPSILON){n.loc=s.LEFT;return}if(C>Number.EPSILON){n.loc=s.RIGHT;return}if(_*S<0||b*P<0){n.loc=s.BEHIND;return}if(Math.sqrt(_*_+b*b)<Math.sqrt(S*S+P*P)){n.loc=s.BEYOND;return}let D;_!==0?D=S/_:D=P/b,n.loc=s.BETWEEN,n.t=D}function a(x,y){const T=[],_=[];for(let b=1;b<x.length;b++){const S=x[b-1],P=x[b];for(let C=1;C<y.length;C++){const D=y[C-1],k=y[C],B=i(S,P,D,k);B!==null&&T.find(O=>O.t<=B.t+Number.EPSILON&&O.t>=B.t-Number.EPSILON)===void 0&&(T.push(B),_.push(new Z(B.x,B.y)))}}return _}function o(x,y,T){const _=new Z;y.getCenter(_);const b=[];return T.forEach(S=>{S.boundingBox.containsPoint(_)&&a(x,S.points).forEach(C=>{b.push({identifier:S.identifier,isCW:S.isCW,point:C})})}),b.sort((S,P)=>S.point.x-P.point.x),b}function c(x,y,T,_,b){(b==null||b==="")&&(b="nonzero");const S=new Z;x.boundingBox.getCenter(S);const P=[new Z(T,S.y),new Z(_,S.y)],C=o(P,x.boundingBox,y);C.sort((j,$)=>j.point.x-$.point.x);const D=[],k=[];C.forEach(j=>{j.identifier===x.identifier?D.push(j):k.push(j)});const B=D[0].point.x,O=[];let U=0;for(;U<k.length&&k[U].point.x<B;)O.length>0&&O[O.length-1]===k[U].identifier?O.pop():O.push(k[U].identifier),U++;if(O.push(x.identifier),b==="evenodd"){const j=O.length%2===0,$=O[O.length-2];return{identifier:x.identifier,isHole:j,for:$}}else if(b==="nonzero"){let j=!0,$=null,Y=null;for(let te=0;te<O.length;te++){const ie=O[te];j?(Y=y[ie].isCW,j=!1,$=ie):Y!==y[ie].isCW&&(Y=y[ie].isCW,j=!0)}return{identifier:x.identifier,isHole:j,for:$}}else console.warn('fill-rule: "'+b+'" is currently not implemented.')}let h=999999999,l=-999999999,d=e.subPaths.map(x=>{const y=x.getPoints();let T=-999999999,_=999999999,b=-999999999,S=999999999;for(let P=0;P<y.length;P++){const C=y[P];C.y>T&&(T=C.y),C.y<_&&(_=C.y),C.x>b&&(b=C.x),C.x<S&&(S=C.x)}return l<=b&&(l=b+1),h>=S&&(h=S-1),{curves:x.curves,points:y,isCW:Us.isClockWise(y),identifier:-1,boundingBox:new ti(new Z(S,_),new Z(b,T))}});d=d.filter(x=>x.points.length>1);for(let x=0;x<d.length;x++)d[x].identifier=x;const p=d.map(x=>c(x,d,h,l,e.userData?e.userData.style.fillRule:void 0)),w=[];return d.forEach(x=>{if(!p[x.identifier].isHole){const T=new si;T.curves=x.curves,p.filter(b=>b.isHole&&b.for===x.identifier).forEach(b=>{const S=d[b.identifier],P=new zt;P.curves=S.curves,T.holes.push(P)}),w.push(T)}}),w}static getStrokeStyle(e,t,s,n,i){return e=e!==void 0?e:1,t=t!==void 0?t:"#000",s=s!==void 0?s:"miter",n=n!==void 0?n:"butt",i=i!==void 0?i:4,{strokeColor:t,strokeWidth:e,strokeLineJoin:s,strokeLineCap:n,strokeMiterLimit:i}}static pointsToStroke(e,t,s,n){const i=[],r=[],a=[];if(ft.pointsToStrokeWithBuffers(e,t,s,n,i,r,a)===0)return null;const o=new ze;return o.setAttribute("position",new Pe(i,3)),o.setAttribute("normal",new Pe(r,3)),o.setAttribute("uv",new Pe(a,2)),o}static pointsToStrokeWithBuffers(e,t,s,n,i,r,a,o){const c=new Z,h=new Z,l=new Z,d=new Z,p=new Z,w=new Z,x=new Z,y=new Z,T=new Z,_=new Z,b=new Z,S=new Z,P=new Z,C=new Z,D=new Z,k=new Z,B=new Z;s=s!==void 0?s:12,n=n!==void 0?n:.001,o=o!==void 0?o:0,e=W(e);const O=e.length;if(O<2)return 0;const U=e[0].equals(e[O-1]);let j,$=e[0],Y;const te=t.strokeWidth/2,ie=1/(O-1);let Q=0,F,re,le,be,Se=!1,Ce=0,E=o*3,A=o*2;m(e[0],e[1],c).multiplyScalar(te),y.copy(e[0]).sub(c),T.copy(e[0]).add(c),_.copy(y),b.copy(T);for(let I=1;I<O;I++){j=e[I],I===O-1?U?Y=e[1]:Y=void 0:Y=e[I+1];const N=c;if(m($,j,N),l.copy(N).multiplyScalar(te),S.copy(j).sub(l),P.copy(j).add(l),F=Q+ie,re=!1,Y!==void 0){m(j,Y,h),l.copy(h).multiplyScalar(te),C.copy(j).sub(l),D.copy(j).add(l),le=!0,l.subVectors(Y,$),N.dot(l)<0&&(le=!1),I===1&&(Se=le),l.subVectors(Y,j),l.normalize();const X=Math.abs(N.dot(l));if(X>Number.EPSILON){const K=te/X;l.multiplyScalar(-K),d.subVectors(j,$),p.copy(d).setLength(K).add(l),k.copy(p).negate();const M=p.length(),g=d.length();d.divideScalar(g),w.subVectors(Y,j);const q=w.length();switch(w.divideScalar(q),d.dot(k)<g&&w.dot(k)<q&&(re=!0),B.copy(p).add(j),k.add(j),be=!1,re?le?(D.copy(k),P.copy(k)):(C.copy(k),S.copy(k)):V(),t.strokeLineJoin){case"bevel":R(le,re,F);break;case"round":z(le,re),le?L(j,S,C,F,0):L(j,D,P,F,1);break;case"miter":case"miter-clip":default:const ne=te*t.strokeMiterLimit/M;if(ne<1)if(t.strokeLineJoin!=="miter-clip"){R(le,re,F);break}else z(le,re),le?(w.subVectors(B,S).multiplyScalar(ne).add(S),x.subVectors(B,C).multiplyScalar(ne).add(C),f(S,F,0),f(w,F,0),f(j,F,.5),f(j,F,.5),f(w,F,0),f(x,F,0),f(j,F,.5),f(x,F,0),f(C,F,0)):(w.subVectors(B,P).multiplyScalar(ne).add(P),x.subVectors(B,D).multiplyScalar(ne).add(D),f(P,F,1),f(w,F,1),f(j,F,.5),f(j,F,.5),f(w,F,1),f(x,F,1),f(j,F,.5),f(x,F,1),f(D,F,1));else re?(le?(f(T,Q,1),f(y,Q,0),f(B,F,0),f(T,Q,1),f(B,F,0),f(k,F,1)):(f(T,Q,1),f(y,Q,0),f(B,F,1),f(y,Q,0),f(k,F,0),f(B,F,1)),le?C.copy(B):D.copy(B)):le?(f(S,F,0),f(B,F,0),f(j,F,.5),f(j,F,.5),f(B,F,0),f(C,F,0)):(f(P,F,1),f(B,F,1),f(j,F,.5),f(j,F,.5),f(B,F,1),f(D,F,1)),be=!0;break}}else V()}else V();!U&&I===O-1&&H(e[0],_,b,le,!0,Q),Q=F,$=j,y.copy(C),T.copy(D)}if(!U)H(j,S,P,le,!1,F);else if(re&&i){let I=B,N=k;Se!==le&&(I=k,N=B),le?(be||Se)&&(N.toArray(i,0*3),N.toArray(i,3*3),be&&I.toArray(i,1*3)):(be||!Se)&&(N.toArray(i,1*3),N.toArray(i,3*3),be&&I.toArray(i,0*3))}return Ce;function m(I,N,X){return X.subVectors(N,I),X.set(-X.y,X.x).normalize()}function f(I,N,X){i&&(i[E]=I.x,i[E+1]=I.y,i[E+2]=0,r&&(r[E]=0,r[E+1]=0,r[E+2]=1),E+=3,a&&(a[A]=N,a[A+1]=X,A+=2)),Ce+=3}function L(I,N,X,K,M){c.copy(N).sub(I).normalize(),h.copy(X).sub(I).normalize();let g=Math.PI;const q=c.dot(h);Math.abs(q)<1&&(g=Math.abs(Math.acos(q))),g/=s,l.copy(N);for(let ne=0,Te=s-1;ne<Te;ne++)d.copy(l).rotateAround(I,g),f(l,K,M),f(d,K,M),f(I,K,.5),l.copy(d);f(d,K,M),f(X,K,M),f(I,K,.5)}function V(){f(T,Q,1),f(y,Q,0),f(S,F,0),f(T,Q,1),f(S,F,0),f(P,F,1)}function R(I,N,X){N?I?(f(T,Q,1),f(y,Q,0),f(S,F,0),f(T,Q,1),f(S,F,0),f(k,F,1),f(S,X,0),f(C,X,0),f(k,X,.5)):(f(T,Q,1),f(y,Q,0),f(P,F,1),f(y,Q,0),f(k,F,0),f(P,F,1),f(P,X,1),f(k,X,0),f(D,X,1)):I?(f(S,X,0),f(C,X,0),f(j,X,.5)):(f(P,X,1),f(D,X,0),f(j,X,.5))}function z(I,N){N&&(I?(f(T,Q,1),f(y,Q,0),f(S,F,0),f(T,Q,1),f(S,F,0),f(k,F,1),f(S,Q,0),f(j,F,.5),f(k,F,1),f(j,F,.5),f(C,Q,0),f(k,F,1)):(f(T,Q,1),f(y,Q,0),f(P,F,1),f(y,Q,0),f(k,F,0),f(P,F,1),f(P,Q,1),f(k,F,0),f(j,F,.5),f(j,F,.5),f(k,F,0),f(D,Q,1)))}function H(I,N,X,K,M,g){switch(t.strokeLineCap){case"round":M?L(I,X,N,g,.5):L(I,N,X,g,.5);break;case"square":if(M)c.subVectors(N,I),h.set(c.y,-c.x),l.addVectors(c,h).add(I),d.subVectors(h,c).add(I),K?(l.toArray(i,1*3),d.toArray(i,0*3),d.toArray(i,3*3)):(l.toArray(i,1*3),a[3*2+1]===1?d.toArray(i,3*3):l.toArray(i,3*3),d.toArray(i,0*3));else{c.subVectors(X,I),h.set(c.y,-c.x),l.addVectors(c,h).add(I),d.subVectors(h,c).add(I);const q=i.length;K?(l.toArray(i,q-1*3),d.toArray(i,q-2*3),d.toArray(i,q-4*3)):(d.toArray(i,q-2*3),l.toArray(i,q-1*3),d.toArray(i,q-4*3))}break}}function W(I){let N=!1;for(let K=1,M=I.length-1;K<M;K++)if(I[K].distanceTo(I[K+1])<n){N=!0;break}if(!N)return I;const X=[];X.push(I[0]);for(let K=1,M=I.length-1;K<M;K++)I[K].distanceTo(I[K+1])>=n&&X.push(I[K]);return X.push(I[I.length-1]),X}}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
 */class Wr{constructor(e,t){v(this,"cache");v(this,"textureAnisotropy");v(this,"_fileLoader");v(this,"_imgLoader");v(this,"_svgLoader");v(this,"_textureLoader");v(this,"_objectLoader");v(this,"_gltfLoader");v(this,"_fbxLoader");this.cache=e,this.textureAnisotropy=t}get fileLoader(){return this._fileLoader||(this._fileLoader=new wt),this._fileLoader}get imageLoader(){return this._imgLoader||(this._imgLoader=new ni),this._imgLoader}get svgLoader(){return this._svgLoader||(this._svgLoader=new ft),this._svgLoader}get textureLoader(){return this._textureLoader||(this._textureLoader=new Ot),this._textureLoader}get objectLoader(){return this._objectLoader||(this._objectLoader=new ii),this._objectLoader}get gltfLoader(){return this._gltfLoader||(this._gltfLoader=new cn),this._gltfLoader}get fbxLoader(){return this._fbxLoader||(this._fbxLoader=new $i),this._fbxLoader}async preload(e,t){return this.cache.add(e,t),new Promise(s=>{const n=/\.fbx$|\.glb$|\.gltf$/.test(t);/\.jpe?g$|\.png$/.test(t)?this.textureLoader.load(t,r=>s(r)):(n?this.fileLoader.setResponseType("arraybuffer"):this.fileLoader.setResponseType("undefined"),this.fileLoader.load(t,r=>s(r)))})}async textureAtlas(e,t,s="JSONHash"){let n=JSON.parse(await this.file(t));if(n.textures){const a=n.textures[0].frames;let o={frames:{}};a.forEach(c=>{o={...o,frames:{...o.frames,[c.filename]:{frame:c.frame,rotated:c.rotated,sourceSize:c.sourceSize,spriteSourceSize:c.spriteSourceSize,trimmed:c.trimmed}}}}),n=o}return{texture:await this.texture(e),json:n}}file(e){const t=this.cache.get(e);return e=t||e,new Promise(s=>{this.fileLoader.load(e,n=>s(n))})}svg(e){const t=this.cache.get(e);return e=t||e,new Promise(s=>{this.svgLoader.load(e,n=>s(n))})}texture(e){if(!/^data:image\/[\S]+;base64,/gm.test(e)){const s=this.cache.get(e);e=s||e}return new Promise(s=>{this.textureLoader.load(e,n=>{n.anisotropy=this.textureAnisotropy,n.needsUpdate=!0,s(n)})})}object(e){const t=this.cache.get(e);return e=t||e,new Promise(s=>{this.objectLoader.load(e,n=>{s(n)})})}gltf(e){const t=this.cache.get(e);return e=t||e,new Promise(s=>{this.gltfLoader.load(e,n=>{s(n)})})}fbx(e){const t=this.cache.get(e);return e=t||e,new Promise(s=>{this.fbxLoader.load(e,n=>{s(n)})})}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
 */class Xr extends Ue{constructor(t,s,n,i){super();v(this,"scene");v(this,"light");v(this,"size");v(this,"color");v(this,"geo");v(this,"mat");v(this,"mesh");this.scene=t,this.light=s,this.size=n,this.color=i,this.geo=new kt(n||.2,16,8),this.mat=new De({color:i||s.color}),this.mesh=new Ae(this.geo,this.mat),this.add(this.mesh),s.add(this)}dispose(){this.mesh.geometry.dispose(),Array.isArray(this.mesh.material)?this.mesh.material.forEach(t=>t.dispose()):this.mesh.material.dispose(),this.remove(this.mesh)}update(){}}class Kr{constructor(e){v(this,"scene");this.scene=e}get helper(){return{directionalLightHelper:(e,t,s)=>{const n=new oi(e,t,s);return this.scene.add(n),n},spotLightHelper:(e,t)=>{const s=new ri(e,t);return this.scene.add(s),s},pointLightHelper:(e,t,s)=>new Xr(this.scene,e,t,s)}}directionalLight(e={}){const{color:t=16777215,intensity:s=1}=e,n=new hs(t,s);return n.castShadow=!0,this.scene.add(n),n}hemisphereLight(e={}){const{skyColor:t=16777215,groundColor:s=16777215,intensity:n=1}=e,i=new ai(t,s,n);return this.scene.add(i),i}ambientLight(e={}){const{color:t=16777215,intensity:s=1}=e,n=new Vs(t,s);return this.scene.add(n),n}pointLight(e={}){const{color:t=16777215,intensity:s=1,distance:n=0,decay:i=1}=e,r=new _t(t,s,n,i);return r.castShadow=!0,this.scene.add(r),r}spotLight(e={}){const{color:t=16777215,intensity:s=10,distance:n=0,angle:i=Math.PI/8,penumbra:r=0,decay:a=1}=e,o=new ls(t,s,n,i,r,a);return o.castShadow=!0,this.scene.add(o),o}rectAreaLight(e={}){const{color:t=16777215,intensity:s=1,width:n=10,height:i=10}=e,r=new ci(t,s,n,i);return this.scene.add(r),r}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2022 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
 */class qr{constructor(e){v(this,"scene");this.scene=e}add(e,t={}){const s=this.make(e,t);return s?this.scene.add(s):console.warn("Could not make heightmap"),s}make(e,t={}){const{image:s}=e,{width:n,height:i}=s,{colorScale:r,heightScale:a=100,colorSpace:o=""}=t,c=document.createElement("canvas");c.width=n,c.height=i;const h=c.getContext("2d");if(!h)return;h.drawImage(e.image,0,0);const l=h.getImageData(0,0,n,i),d=new lt(10,10,n-1,i-1);let p={color:13421772,side:cs};r&&(p={...p,vertexColors:!0});const w=new at(p),x=new qs(d,w);x.receiveShadow=x.castShadow=!0,x.shape="concave";const y=d.attributes.position.array;for(let T=0;T<y.length;T++){const _=l.data[T*4]/a;y[T*3+2]=_}if(r){const T=d.attributes.position.count;d.setAttribute("color",new Oe(new Float32Array(T*3),3));const _=new oe,b=d.attributes.position,S=d.attributes.color;let P,C;for(let D=0;D<T;D++)P=b.getZ(D),C=r(P).hsl(),_.setHSL(C[0]/360,C[1],C[2],o),S.setXYZ(D,_.r,_.g,_.b)}return x.rotateX(-Math.PI/2),x.updateMatrix(),d.computeVertexNormals(),x.name="heightmap",x}}const Ps={type:"change"},ds={type:"start"},un={type:"end"},Et=new hi,Rs=new Rt,Yr=Math.cos(70*me.DEG2RAD),pe=new G,we=2*Math.PI,ae={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6},Yt=1e-6;class Qr extends li{constructor(e,t=null){super(e,t),this.state=ae.NONE,this.enabled=!0,this.target=new G,this.cursor=new G,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minTargetRadius=0,this.maxTargetRadius=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.zoomToCursor=!1,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:nt.ROTATE,MIDDLE:nt.DOLLY,RIGHT:nt.PAN},this.touches={ONE:Je.ROTATE,TWO:Je.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this._lastPosition=new G,this._lastQuaternion=new ge,this._lastTargetPosition=new G,this._quat=new ge().setFromUnitVectors(e.up,new G(0,1,0)),this._quatInverse=this._quat.clone().invert(),this._spherical=new ys,this._sphericalDelta=new ys,this._scale=1,this._panOffset=new G,this._rotateStart=new Z,this._rotateEnd=new Z,this._rotateDelta=new Z,this._panStart=new Z,this._panEnd=new Z,this._panDelta=new Z,this._dollyStart=new Z,this._dollyEnd=new Z,this._dollyDelta=new Z,this._dollyDirection=new G,this._mouse=new Z,this._performCursorZoom=!1,this._pointers=[],this._pointerPositions={},this._controlActive=!1,this._onPointerMove=$r.bind(this),this._onPointerDown=Zr.bind(this),this._onPointerUp=Jr.bind(this),this._onContextMenu=oo.bind(this),this._onMouseWheel=so.bind(this),this._onKeyDown=no.bind(this),this._onTouchStart=io.bind(this),this._onTouchMove=ro.bind(this),this._onMouseDown=eo.bind(this),this._onMouseMove=to.bind(this),this._interceptControlDown=ao.bind(this),this._interceptControlUp=co.bind(this),this.domElement!==null&&this.connect(),this.update()}connect(){this.domElement.addEventListener("pointerdown",this._onPointerDown),this.domElement.addEventListener("pointercancel",this._onPointerUp),this.domElement.addEventListener("contextmenu",this._onContextMenu),this.domElement.addEventListener("wheel",this._onMouseWheel,{passive:!1}),this.domElement.getRootNode().addEventListener("keydown",this._interceptControlDown,{passive:!0,capture:!0}),this.domElement.style.touchAction="none"}disconnect(){this.domElement.removeEventListener("pointerdown",this._onPointerDown),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.domElement.removeEventListener("pointercancel",this._onPointerUp),this.domElement.removeEventListener("wheel",this._onMouseWheel),this.domElement.removeEventListener("contextmenu",this._onContextMenu),this.stopListenToKeyEvents(),this.domElement.getRootNode().removeEventListener("keydown",this._interceptControlDown,{capture:!0}),this.domElement.style.touchAction="auto"}dispose(){this.disconnect()}getPolarAngle(){return this._spherical.phi}getAzimuthalAngle(){return this._spherical.theta}getDistance(){return this.object.position.distanceTo(this.target)}listenToKeyEvents(e){e.addEventListener("keydown",this._onKeyDown),this._domElementKeyEvents=e}stopListenToKeyEvents(){this._domElementKeyEvents!==null&&(this._domElementKeyEvents.removeEventListener("keydown",this._onKeyDown),this._domElementKeyEvents=null)}saveState(){this.target0.copy(this.target),this.position0.copy(this.object.position),this.zoom0=this.object.zoom}reset(){this.target.copy(this.target0),this.object.position.copy(this.position0),this.object.zoom=this.zoom0,this.object.updateProjectionMatrix(),this.dispatchEvent(Ps),this.update(),this.state=ae.NONE}update(e=null){const t=this.object.position;pe.copy(t).sub(this.target),pe.applyQuaternion(this._quat),this._spherical.setFromVector3(pe),this.autoRotate&&this.state===ae.NONE&&this._rotateLeft(this._getAutoRotationAngle(e)),this.enableDamping?(this._spherical.theta+=this._sphericalDelta.theta*this.dampingFactor,this._spherical.phi+=this._sphericalDelta.phi*this.dampingFactor):(this._spherical.theta+=this._sphericalDelta.theta,this._spherical.phi+=this._sphericalDelta.phi);let s=this.minAzimuthAngle,n=this.maxAzimuthAngle;isFinite(s)&&isFinite(n)&&(s<-Math.PI?s+=we:s>Math.PI&&(s-=we),n<-Math.PI?n+=we:n>Math.PI&&(n-=we),s<=n?this._spherical.theta=Math.max(s,Math.min(n,this._spherical.theta)):this._spherical.theta=this._spherical.theta>(s+n)/2?Math.max(s,this._spherical.theta):Math.min(n,this._spherical.theta)),this._spherical.phi=Math.max(this.minPolarAngle,Math.min(this.maxPolarAngle,this._spherical.phi)),this._spherical.makeSafe(),this.enableDamping===!0?this.target.addScaledVector(this._panOffset,this.dampingFactor):this.target.add(this._panOffset),this.target.sub(this.cursor),this.target.clampLength(this.minTargetRadius,this.maxTargetRadius),this.target.add(this.cursor);let i=!1;if(this.zoomToCursor&&this._performCursorZoom||this.object.isOrthographicCamera)this._spherical.radius=this._clampDistance(this._spherical.radius);else{const r=this._spherical.radius;this._spherical.radius=this._clampDistance(this._spherical.radius*this._scale),i=r!=this._spherical.radius}if(pe.setFromSpherical(this._spherical),pe.applyQuaternion(this._quatInverse),t.copy(this.target).add(pe),this.object.lookAt(this.target),this.enableDamping===!0?(this._sphericalDelta.theta*=1-this.dampingFactor,this._sphericalDelta.phi*=1-this.dampingFactor,this._panOffset.multiplyScalar(1-this.dampingFactor)):(this._sphericalDelta.set(0,0,0),this._panOffset.set(0,0,0)),this.zoomToCursor&&this._performCursorZoom){let r=null;if(this.object.isPerspectiveCamera){const a=pe.length();r=this._clampDistance(a*this._scale);const o=a-r;this.object.position.addScaledVector(this._dollyDirection,o),this.object.updateMatrixWorld(),i=!!o}else if(this.object.isOrthographicCamera){const a=new G(this._mouse.x,this._mouse.y,0);a.unproject(this.object);const o=this.object.zoom;this.object.zoom=Math.max(this.minZoom,Math.min(this.maxZoom,this.object.zoom/this._scale)),this.object.updateProjectionMatrix(),i=o!==this.object.zoom;const c=new G(this._mouse.x,this._mouse.y,0);c.unproject(this.object),this.object.position.sub(c).add(a),this.object.updateMatrixWorld(),r=pe.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),this.zoomToCursor=!1;r!==null&&(this.screenSpacePanning?this.target.set(0,0,-1).transformDirection(this.object.matrix).multiplyScalar(r).add(this.object.position):(Et.origin.copy(this.object.position),Et.direction.set(0,0,-1).transformDirection(this.object.matrix),Math.abs(this.object.up.dot(Et.direction))<Yr?this.object.lookAt(this.target):(Rs.setFromNormalAndCoplanarPoint(this.object.up,this.target),Et.intersectPlane(Rs,this.target))))}else if(this.object.isOrthographicCamera){const r=this.object.zoom;this.object.zoom=Math.max(this.minZoom,Math.min(this.maxZoom,this.object.zoom/this._scale)),r!==this.object.zoom&&(this.object.updateProjectionMatrix(),i=!0)}return this._scale=1,this._performCursorZoom=!1,i||this._lastPosition.distanceToSquared(this.object.position)>Yt||8*(1-this._lastQuaternion.dot(this.object.quaternion))>Yt||this._lastTargetPosition.distanceToSquared(this.target)>Yt?(this.dispatchEvent(Ps),this._lastPosition.copy(this.object.position),this._lastQuaternion.copy(this.object.quaternion),this._lastTargetPosition.copy(this.target),!0):!1}_getAutoRotationAngle(e){return e!==null?we/60*this.autoRotateSpeed*e:we/60/60*this.autoRotateSpeed}_getZoomScale(e){const t=Math.abs(e*.01);return Math.pow(.95,this.zoomSpeed*t)}_rotateLeft(e){this._sphericalDelta.theta-=e}_rotateUp(e){this._sphericalDelta.phi-=e}_panLeft(e,t){pe.setFromMatrixColumn(t,0),pe.multiplyScalar(-e),this._panOffset.add(pe)}_panUp(e,t){this.screenSpacePanning===!0?pe.setFromMatrixColumn(t,1):(pe.setFromMatrixColumn(t,0),pe.crossVectors(this.object.up,pe)),pe.multiplyScalar(e),this._panOffset.add(pe)}_pan(e,t){const s=this.domElement;if(this.object.isPerspectiveCamera){const n=this.object.position;pe.copy(n).sub(this.target);let i=pe.length();i*=Math.tan(this.object.fov/2*Math.PI/180),this._panLeft(2*e*i/s.clientHeight,this.object.matrix),this._panUp(2*t*i/s.clientHeight,this.object.matrix)}else this.object.isOrthographicCamera?(this._panLeft(e*(this.object.right-this.object.left)/this.object.zoom/s.clientWidth,this.object.matrix),this._panUp(t*(this.object.top-this.object.bottom)/this.object.zoom/s.clientHeight,this.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),this.enablePan=!1)}_dollyOut(e){this.object.isPerspectiveCamera||this.object.isOrthographicCamera?this._scale/=e:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),this.enableZoom=!1)}_dollyIn(e){this.object.isPerspectiveCamera||this.object.isOrthographicCamera?this._scale*=e:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),this.enableZoom=!1)}_updateZoomParameters(e,t){if(!this.zoomToCursor)return;this._performCursorZoom=!0;const s=this.domElement.getBoundingClientRect(),n=e-s.left,i=t-s.top,r=s.width,a=s.height;this._mouse.x=n/r*2-1,this._mouse.y=-(i/a)*2+1,this._dollyDirection.set(this._mouse.x,this._mouse.y,1).unproject(this.object).sub(this.object.position).normalize()}_clampDistance(e){return Math.max(this.minDistance,Math.min(this.maxDistance,e))}_handleMouseDownRotate(e){this._rotateStart.set(e.clientX,e.clientY)}_handleMouseDownDolly(e){this._updateZoomParameters(e.clientX,e.clientX),this._dollyStart.set(e.clientX,e.clientY)}_handleMouseDownPan(e){this._panStart.set(e.clientX,e.clientY)}_handleMouseMoveRotate(e){this._rotateEnd.set(e.clientX,e.clientY),this._rotateDelta.subVectors(this._rotateEnd,this._rotateStart).multiplyScalar(this.rotateSpeed);const t=this.domElement;this._rotateLeft(we*this._rotateDelta.x/t.clientHeight),this._rotateUp(we*this._rotateDelta.y/t.clientHeight),this._rotateStart.copy(this._rotateEnd),this.update()}_handleMouseMoveDolly(e){this._dollyEnd.set(e.clientX,e.clientY),this._dollyDelta.subVectors(this._dollyEnd,this._dollyStart),this._dollyDelta.y>0?this._dollyOut(this._getZoomScale(this._dollyDelta.y)):this._dollyDelta.y<0&&this._dollyIn(this._getZoomScale(this._dollyDelta.y)),this._dollyStart.copy(this._dollyEnd),this.update()}_handleMouseMovePan(e){this._panEnd.set(e.clientX,e.clientY),this._panDelta.subVectors(this._panEnd,this._panStart).multiplyScalar(this.panSpeed),this._pan(this._panDelta.x,this._panDelta.y),this._panStart.copy(this._panEnd),this.update()}_handleMouseWheel(e){this._updateZoomParameters(e.clientX,e.clientY),e.deltaY<0?this._dollyIn(this._getZoomScale(e.deltaY)):e.deltaY>0&&this._dollyOut(this._getZoomScale(e.deltaY)),this.update()}_handleKeyDown(e){let t=!1;switch(e.code){case this.keys.UP:e.ctrlKey||e.metaKey||e.shiftKey?this.enableRotate&&this._rotateUp(we*this.rotateSpeed/this.domElement.clientHeight):this.enablePan&&this._pan(0,this.keyPanSpeed),t=!0;break;case this.keys.BOTTOM:e.ctrlKey||e.metaKey||e.shiftKey?this.enableRotate&&this._rotateUp(-we*this.rotateSpeed/this.domElement.clientHeight):this.enablePan&&this._pan(0,-this.keyPanSpeed),t=!0;break;case this.keys.LEFT:e.ctrlKey||e.metaKey||e.shiftKey?this.enableRotate&&this._rotateLeft(we*this.rotateSpeed/this.domElement.clientHeight):this.enablePan&&this._pan(this.keyPanSpeed,0),t=!0;break;case this.keys.RIGHT:e.ctrlKey||e.metaKey||e.shiftKey?this.enableRotate&&this._rotateLeft(-we*this.rotateSpeed/this.domElement.clientHeight):this.enablePan&&this._pan(-this.keyPanSpeed,0),t=!0;break}t&&(e.preventDefault(),this.update())}_handleTouchStartRotate(e){if(this._pointers.length===1)this._rotateStart.set(e.pageX,e.pageY);else{const t=this._getSecondPointerPosition(e),s=.5*(e.pageX+t.x),n=.5*(e.pageY+t.y);this._rotateStart.set(s,n)}}_handleTouchStartPan(e){if(this._pointers.length===1)this._panStart.set(e.pageX,e.pageY);else{const t=this._getSecondPointerPosition(e),s=.5*(e.pageX+t.x),n=.5*(e.pageY+t.y);this._panStart.set(s,n)}}_handleTouchStartDolly(e){const t=this._getSecondPointerPosition(e),s=e.pageX-t.x,n=e.pageY-t.y,i=Math.sqrt(s*s+n*n);this._dollyStart.set(0,i)}_handleTouchStartDollyPan(e){this.enableZoom&&this._handleTouchStartDolly(e),this.enablePan&&this._handleTouchStartPan(e)}_handleTouchStartDollyRotate(e){this.enableZoom&&this._handleTouchStartDolly(e),this.enableRotate&&this._handleTouchStartRotate(e)}_handleTouchMoveRotate(e){if(this._pointers.length==1)this._rotateEnd.set(e.pageX,e.pageY);else{const s=this._getSecondPointerPosition(e),n=.5*(e.pageX+s.x),i=.5*(e.pageY+s.y);this._rotateEnd.set(n,i)}this._rotateDelta.subVectors(this._rotateEnd,this._rotateStart).multiplyScalar(this.rotateSpeed);const t=this.domElement;this._rotateLeft(we*this._rotateDelta.x/t.clientHeight),this._rotateUp(we*this._rotateDelta.y/t.clientHeight),this._rotateStart.copy(this._rotateEnd)}_handleTouchMovePan(e){if(this._pointers.length===1)this._panEnd.set(e.pageX,e.pageY);else{const t=this._getSecondPointerPosition(e),s=.5*(e.pageX+t.x),n=.5*(e.pageY+t.y);this._panEnd.set(s,n)}this._panDelta.subVectors(this._panEnd,this._panStart).multiplyScalar(this.panSpeed),this._pan(this._panDelta.x,this._panDelta.y),this._panStart.copy(this._panEnd)}_handleTouchMoveDolly(e){const t=this._getSecondPointerPosition(e),s=e.pageX-t.x,n=e.pageY-t.y,i=Math.sqrt(s*s+n*n);this._dollyEnd.set(0,i),this._dollyDelta.set(0,Math.pow(this._dollyEnd.y/this._dollyStart.y,this.zoomSpeed)),this._dollyOut(this._dollyDelta.y),this._dollyStart.copy(this._dollyEnd);const r=(e.pageX+t.x)*.5,a=(e.pageY+t.y)*.5;this._updateZoomParameters(r,a)}_handleTouchMoveDollyPan(e){this.enableZoom&&this._handleTouchMoveDolly(e),this.enablePan&&this._handleTouchMovePan(e)}_handleTouchMoveDollyRotate(e){this.enableZoom&&this._handleTouchMoveDolly(e),this.enableRotate&&this._handleTouchMoveRotate(e)}_addPointer(e){this._pointers.push(e.pointerId)}_removePointer(e){delete this._pointerPositions[e.pointerId];for(let t=0;t<this._pointers.length;t++)if(this._pointers[t]==e.pointerId){this._pointers.splice(t,1);return}}_isTrackingPointer(e){for(let t=0;t<this._pointers.length;t++)if(this._pointers[t]==e.pointerId)return!0;return!1}_trackPointer(e){let t=this._pointerPositions[e.pointerId];t===void 0&&(t=new Z,this._pointerPositions[e.pointerId]=t),t.set(e.pageX,e.pageY)}_getSecondPointerPosition(e){const t=e.pointerId===this._pointers[0]?this._pointers[1]:this._pointers[0];return this._pointerPositions[t]}_customWheelEvent(e){const t=e.deltaMode,s={clientX:e.clientX,clientY:e.clientY,deltaY:e.deltaY};switch(t){case 1:s.deltaY*=16;break;case 2:s.deltaY*=100;break}return e.ctrlKey&&!this._controlActive&&(s.deltaY*=10),s}}function Zr(u){this.enabled!==!1&&(this._pointers.length===0&&(this.domElement.setPointerCapture(u.pointerId),this.domElement.addEventListener("pointermove",this._onPointerMove),this.domElement.addEventListener("pointerup",this._onPointerUp)),!this._isTrackingPointer(u)&&(this._addPointer(u),u.pointerType==="touch"?this._onTouchStart(u):this._onMouseDown(u)))}function $r(u){this.enabled!==!1&&(u.pointerType==="touch"?this._onTouchMove(u):this._onMouseMove(u))}function Jr(u){switch(this._removePointer(u),this._pointers.length){case 0:this.domElement.releasePointerCapture(u.pointerId),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.dispatchEvent(un),this.state=ae.NONE;break;case 1:const e=this._pointers[0],t=this._pointerPositions[e];this._onTouchStart({pointerId:e,pageX:t.x,pageY:t.y});break}}function eo(u){let e;switch(u.button){case 0:e=this.mouseButtons.LEFT;break;case 1:e=this.mouseButtons.MIDDLE;break;case 2:e=this.mouseButtons.RIGHT;break;default:e=-1}switch(e){case nt.DOLLY:if(this.enableZoom===!1)return;this._handleMouseDownDolly(u),this.state=ae.DOLLY;break;case nt.ROTATE:if(u.ctrlKey||u.metaKey||u.shiftKey){if(this.enablePan===!1)return;this._handleMouseDownPan(u),this.state=ae.PAN}else{if(this.enableRotate===!1)return;this._handleMouseDownRotate(u),this.state=ae.ROTATE}break;case nt.PAN:if(u.ctrlKey||u.metaKey||u.shiftKey){if(this.enableRotate===!1)return;this._handleMouseDownRotate(u),this.state=ae.ROTATE}else{if(this.enablePan===!1)return;this._handleMouseDownPan(u),this.state=ae.PAN}break;default:this.state=ae.NONE}this.state!==ae.NONE&&this.dispatchEvent(ds)}function to(u){switch(this.state){case ae.ROTATE:if(this.enableRotate===!1)return;this._handleMouseMoveRotate(u);break;case ae.DOLLY:if(this.enableZoom===!1)return;this._handleMouseMoveDolly(u);break;case ae.PAN:if(this.enablePan===!1)return;this._handleMouseMovePan(u);break}}function so(u){this.enabled===!1||this.enableZoom===!1||this.state!==ae.NONE||(u.preventDefault(),this.dispatchEvent(ds),this._handleMouseWheel(this._customWheelEvent(u)),this.dispatchEvent(un))}function no(u){this.enabled!==!1&&this._handleKeyDown(u)}function io(u){switch(this._trackPointer(u),this._pointers.length){case 1:switch(this.touches.ONE){case Je.ROTATE:if(this.enableRotate===!1)return;this._handleTouchStartRotate(u),this.state=ae.TOUCH_ROTATE;break;case Je.PAN:if(this.enablePan===!1)return;this._handleTouchStartPan(u),this.state=ae.TOUCH_PAN;break;default:this.state=ae.NONE}break;case 2:switch(this.touches.TWO){case Je.DOLLY_PAN:if(this.enableZoom===!1&&this.enablePan===!1)return;this._handleTouchStartDollyPan(u),this.state=ae.TOUCH_DOLLY_PAN;break;case Je.DOLLY_ROTATE:if(this.enableZoom===!1&&this.enableRotate===!1)return;this._handleTouchStartDollyRotate(u),this.state=ae.TOUCH_DOLLY_ROTATE;break;default:this.state=ae.NONE}break;default:this.state=ae.NONE}this.state!==ae.NONE&&this.dispatchEvent(ds)}function ro(u){switch(this._trackPointer(u),this.state){case ae.TOUCH_ROTATE:if(this.enableRotate===!1)return;this._handleTouchMoveRotate(u),this.update();break;case ae.TOUCH_PAN:if(this.enablePan===!1)return;this._handleTouchMovePan(u),this.update();break;case ae.TOUCH_DOLLY_PAN:if(this.enableZoom===!1&&this.enablePan===!1)return;this._handleTouchMoveDollyPan(u),this.update();break;case ae.TOUCH_DOLLY_ROTATE:if(this.enableZoom===!1&&this.enableRotate===!1)return;this._handleTouchMoveDollyRotate(u),this.update();break;default:this.state=ae.NONE}}function oo(u){this.enabled!==!1&&u.preventDefault()}function ao(u){u.key==="Control"&&(this._controlActive=!0,this.domElement.getRootNode().addEventListener("keyup",this._interceptControlUp,{passive:!0,capture:!0}))}function co(u){u.key==="Control"&&(this._controlActive=!1,this.domElement.getRootNode().removeEventListener("keyup",this._interceptControlUp,{passive:!0,capture:!0}))}class lo{constructor(e,t,s,n,i,r,a){v(this,"scene");v(this,"renderer");v(this,"camera");v(this,"lights");v(this,"physics");v(this,"load");v(this,"factories");this.scene=e,this.renderer=t,this.camera=s,this.lights=n,this.physics=i,this.load=r,this.factories=a}async warpSpeed(...e){let t={};const s=e.filter(o=>/^-\w+/.test(o)),n=s.length>0;if((e.length===0||n)&&(e=["light","camera","lookAtCenter","ground","grid","orbitControls","fog","sky"]),n&&s.map(c=>c.substr(1)).forEach(c=>{const h=e.indexOf(c);e.splice(h,1)}),e.includes("sky")){const o=["varying vec3 vWorldPosition;","","void main() {","","vec4 worldPosition = modelMatrix * vec4( position, 1.0 );","vWorldPosition = worldPosition.xyz;","","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","","}"].join(`
`),c=["uniform vec3 topColor;","uniform vec3 bottomColor;","uniform float offset;","uniform float exponent;","","varying vec3 vWorldPosition;","","void main() {","","float h = normalize( vWorldPosition + offset ).y;","gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h , 0.0), exponent ), 0.0 ) ), 1.0 );","","}"].join(`
`),h={topColor:{value:new oe(30719)},bottomColor:{value:new oe(15595007)},offset:{value:33},exponent:{value:.6}};var i=new kt(500,32,15),r=new Ft({uniforms:h,vertexShader:o,fragmentShader:c,side:ui}),a=new Ae(i,r);this.scene.add(a)}if(e.includes("camera")&&(this.camera.position.set(0,6,12),t={camera:this.camera,...t}),e.includes("light")){const c=this.lights.hemisphereLight({skyColor:16777215,groundColor:0,intensity:1}),h=this.lights.ambientLight({color:16777215,intensity:1}),l=this.lights.directionalLight({color:16777215,intensity:1});l.position.set(100,200,50);const d=20;l.shadow.camera.top=d,l.shadow.camera.bottom=-20,l.shadow.camera.left=-20,l.shadow.camera.right=d,l.shadow.mapSize.set(1024,1024),t={lights:{ambientLight:h,directionalLight:l,hemisphereLight:c},...t}}if(e.includes("lookAtCenter")&&this.camera.lookAt(this.scene.position),e.includes("ground")){const o=e.includes("grid"),h=await this.load.texture("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqaXHeAAAABHNCSVQICAgIfAhkiAAAAAlwSFlzAAAOnAAADusBZ+q87AAAAJtJREFUeJzt0EENwDAAxLDbNP6UOxh+NEYQ5dl2drFv286598GrA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAa4AO0BqgA7QG6ACtATpAu37AD8eaBH5JQdVbAAAAAElFTkSuQmCC");h.wrapS=h.wrapT=je,h.repeat.set(21,21);const l={name:"ground",width:21,height:21,depth:1,y:-.5},d={phong:{map:o?h:null,color:16777215}};let p;window.__loadPhysics?(p=this.physics.add.ground(l,d),p.body.setRestitution(1)):p=this.factories.add.ground(l,d),p.receiveShadow=!0,t={ground:p,...t}}return e.includes("orbitControls")&&(t={orbitControls:new Qr(this.camera,document.getElementById("enable3d-phaser-canvas")||this.renderer.domElement),...t}),t}}class ho{constructor(){v(this,"_mixers",[])}animationMixer(e){const t=new Is(e);return this.mixers.add(t),t}get mixers(){return{create:e=>this.animationMixer(e),add:e=>this._mixers.push(e),get:()=>this._mixers,update:e=>{var t;return(t=this._mixers)==null?void 0:t.forEach(s=>s.update(e/1e3))}}}}class mt extends Ae{constructor(e,t={}){super(e),this.isReflector=!0,this.type="Reflector",this.camera=new yt;const s=this,n=t.color!==void 0?new oe(t.color):new oe(8355711),i=t.textureWidth||512,r=t.textureHeight||512,a=t.clipBias||0,o=t.shader||mt.ReflectorShader,c=t.multisample!==void 0?t.multisample:4,h=new Rt,l=new G,d=new G,p=new G,w=new se,x=new G(0,0,-1),y=new Ne,T=new G,_=new G,b=new Ne,S=new se,P=this.camera,C=new Xs(i,r,{samples:c,type:Ks}),D=new Ft({name:o.name!==void 0?o.name:"unspecified",uniforms:us.clone(o.uniforms),fragmentShader:o.fragmentShader,vertexShader:o.vertexShader});D.uniforms.tDiffuse.value=C.texture,D.uniforms.color.value=n,D.uniforms.textureMatrix.value=S,this.material=D,this.onBeforeRender=function(k,B,O){if(d.setFromMatrixPosition(s.matrixWorld),p.setFromMatrixPosition(O.matrixWorld),w.extractRotation(s.matrixWorld),l.set(0,0,1),l.applyMatrix4(w),T.subVectors(d,p),T.dot(l)>0)return;T.reflect(l).negate(),T.add(d),w.extractRotation(O.matrixWorld),x.set(0,0,-1),x.applyMatrix4(w),x.add(p),_.subVectors(d,x),_.reflect(l).negate(),_.add(d),P.position.copy(T),P.up.set(0,1,0),P.up.applyMatrix4(w),P.up.reflect(l),P.lookAt(_),P.far=O.far,P.updateMatrixWorld(),P.projectionMatrix.copy(O.projectionMatrix),S.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),S.multiply(P.projectionMatrix),S.multiply(P.matrixWorldInverse),S.multiply(s.matrixWorld),h.setFromNormalAndCoplanarPoint(l,d),h.applyMatrix4(P.matrixWorldInverse),y.set(h.normal.x,h.normal.y,h.normal.z,h.constant);const U=P.projectionMatrix;b.x=(Math.sign(y.x)+U.elements[8])/U.elements[0],b.y=(Math.sign(y.y)+U.elements[9])/U.elements[5],b.z=-1,b.w=(1+U.elements[10])/U.elements[14],y.multiplyScalar(2/y.dot(b)),U.elements[2]=y.x,U.elements[6]=y.y,U.elements[10]=y.z+1-a,U.elements[14]=y.w,s.visible=!1;const j=k.getRenderTarget(),$=k.xr.enabled,Y=k.shadowMap.autoUpdate;k.xr.enabled=!1,k.shadowMap.autoUpdate=!1,k.setRenderTarget(C),k.state.buffers.depth.setMask(!0),k.autoClear===!1&&k.clear(),k.render(B,P),k.xr.enabled=$,k.shadowMap.autoUpdate=Y,k.setRenderTarget(j);const te=O.viewport;te!==void 0&&k.state.viewport(te),s.visible=!0},this.getRenderTarget=function(){return C},this.dispose=function(){C.dispose(),s.material.dispose()}}}mt.ReflectorShader={name:"ReflectorShader",uniforms:{color:{value:null},tDiffuse:{value:null},textureMatrix:{value:null}},vertexShader:`
		uniform mat4 textureMatrix;
		varying vec4 vUv;

		#include <common>
		#include <logdepthbuf_pars_vertex>

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			#include <logdepthbuf_vertex>

		}`,fragmentShader:`
		uniform vec3 color;
		uniform sampler2D tDiffuse;
		varying vec4 vUv;

		#include <logdepthbuf_pars_fragment>

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			#include <logdepthbuf_fragment>

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}`};class gt extends Ae{constructor(e,t={}){super(e),this.isRefractor=!0,this.type="Refractor",this.camera=new yt;const s=this,n=t.color!==void 0?new oe(t.color):new oe(8355711),i=t.textureWidth||512,r=t.textureHeight||512,a=t.clipBias||0,o=t.shader||gt.RefractorShader,c=t.multisample!==void 0?t.multisample:4,h=this.camera;h.matrixAutoUpdate=!1,h.userData.refractor=!0;const l=new Rt,d=new se,p=new Xs(i,r,{samples:c,type:Ks});this.material=new Ft({name:o.name!==void 0?o.name:"unspecified",uniforms:us.clone(o.uniforms),vertexShader:o.vertexShader,fragmentShader:o.fragmentShader,transparent:!0}),this.material.uniforms.color.value=n,this.material.uniforms.tDiffuse.value=p.texture,this.material.uniforms.textureMatrix.value=d;const w=function(){const b=new G,S=new G,P=new se,C=new G,D=new G;return function(B){return b.setFromMatrixPosition(s.matrixWorld),S.setFromMatrixPosition(B.matrixWorld),C.subVectors(b,S),P.extractRotation(s.matrixWorld),D.set(0,0,1),D.applyMatrix4(P),C.dot(D)<0}}(),x=function(){const b=new G,S=new G,P=new ge,C=new G;return function(){s.matrixWorld.decompose(S,P,C),b.set(0,0,1).applyQuaternion(P).normalize(),b.negate(),l.setFromNormalAndCoplanarPoint(b,S)}}(),y=function(){const b=new Rt,S=new Ne,P=new Ne;return function(D){h.matrixWorld.copy(D.matrixWorld),h.matrixWorldInverse.copy(h.matrixWorld).invert(),h.projectionMatrix.copy(D.projectionMatrix),h.far=D.far,b.copy(l),b.applyMatrix4(h.matrixWorldInverse),S.set(b.normal.x,b.normal.y,b.normal.z,b.constant);const k=h.projectionMatrix;P.x=(Math.sign(S.x)+k.elements[8])/k.elements[0],P.y=(Math.sign(S.y)+k.elements[9])/k.elements[5],P.z=-1,P.w=(1+k.elements[10])/k.elements[14],S.multiplyScalar(2/S.dot(P)),k.elements[2]=S.x,k.elements[6]=S.y,k.elements[10]=S.z+1-a,k.elements[14]=S.w}}();function T(b){d.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),d.multiply(b.projectionMatrix),d.multiply(b.matrixWorldInverse),d.multiply(s.matrixWorld)}function _(b,S,P){s.visible=!1;const C=b.getRenderTarget(),D=b.xr.enabled,k=b.shadowMap.autoUpdate;b.xr.enabled=!1,b.shadowMap.autoUpdate=!1,b.setRenderTarget(p),b.autoClear===!1&&b.clear(),b.render(S,h),b.xr.enabled=D,b.shadowMap.autoUpdate=k,b.setRenderTarget(C);const B=P.viewport;B!==void 0&&b.state.viewport(B),s.visible=!0}this.onBeforeRender=function(b,S,P){P.userData.refractor!==!0&&w(P)&&(x(),T(P),y(P),_(b,S,P))},this.getRenderTarget=function(){return p},this.dispose=function(){p.dispose(),s.material.dispose()}}}gt.RefractorShader={name:"RefractorShader",uniforms:{color:{value:null},tDiffuse:{value:null},textureMatrix:{value:null}},vertexShader:`

		uniform mat4 textureMatrix;

		varying vec4 vUv;

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );
			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

		}`,fragmentShader:`

		uniform vec3 color;
		uniform sampler2D tDiffuse;

		varying vec4 vUv;

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}`};class Nt extends Ae{constructor(e,t={}){super(e),this.isWater=!0,this.type="Water";const s=this,n=t.color!==void 0?new oe(t.color):new oe(16777215),i=t.textureWidth!==void 0?t.textureWidth:512,r=t.textureHeight!==void 0?t.textureHeight:512,a=t.clipBias!==void 0?t.clipBias:0,o=t.flowDirection!==void 0?t.flowDirection:new Z(1,0),c=t.flowSpeed!==void 0?t.flowSpeed:.03,h=t.reflectivity!==void 0?t.reflectivity:.02,l=t.scale!==void 0?t.scale:1,d=t.shader!==void 0?t.shader:Nt.WaterShader,p=new Ot,w=t.flowMap||void 0,x=t.normalMap0||p.load("textures/water/Water_1_M_Normal.jpg"),y=t.normalMap1||p.load("textures/water/Water_2_M_Normal.jpg"),T=.15,_=T*.5,b=new se,S=new pi;if(mt===void 0){console.error("THREE.Water: Required component Reflector not found.");return}if(gt===void 0){console.error("THREE.Water: Required component Refractor not found.");return}const P=new mt(e,{textureWidth:i,textureHeight:r,clipBias:a}),C=new gt(e,{textureWidth:i,textureHeight:r,clipBias:a});P.matrixAutoUpdate=!1,C.matrixAutoUpdate=!1,this.material=new Ft({name:d.name,uniforms:us.merge([di.fog,d.uniforms]),vertexShader:d.vertexShader,fragmentShader:d.fragmentShader,transparent:!0,fog:!0}),w!==void 0?(this.material.defines.USE_FLOWMAP="",this.material.uniforms.tFlowMap={type:"t",value:w}):this.material.uniforms.flowDirection={type:"v2",value:o},x.wrapS=x.wrapT=je,y.wrapS=y.wrapT=je,this.material.uniforms.tReflectionMap.value=P.getRenderTarget().texture,this.material.uniforms.tRefractionMap.value=C.getRenderTarget().texture,this.material.uniforms.tNormalMap0.value=x,this.material.uniforms.tNormalMap1.value=y,this.material.uniforms.color.value=n,this.material.uniforms.reflectivity.value=h,this.material.uniforms.textureMatrix.value=b,this.material.uniforms.config.value.x=0,this.material.uniforms.config.value.y=_,this.material.uniforms.config.value.z=_,this.material.uniforms.config.value.w=l;function D(B){b.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),b.multiply(B.projectionMatrix),b.multiply(B.matrixWorldInverse),b.multiply(s.matrixWorld)}function k(){const B=S.getDelta(),O=s.material.uniforms.config;O.value.x+=c*B,O.value.y=O.value.x+_,O.value.x>=T?(O.value.x=0,O.value.y=_):O.value.y>=T&&(O.value.y=O.value.y-T)}this.onBeforeRender=function(B,O,U){D(U),k(),s.visible=!1,P.matrixWorld.copy(s.matrixWorld),C.matrixWorld.copy(s.matrixWorld),P.onBeforeRender(B,O,U),C.onBeforeRender(B,O,U),s.visible=!0}}}Nt.WaterShader={name:"WaterShader",uniforms:{color:{type:"c",value:null},reflectivity:{type:"f",value:0},tReflectionMap:{type:"t",value:null},tRefractionMap:{type:"t",value:null},tNormalMap0:{type:"t",value:null},tNormalMap1:{type:"t",value:null},textureMatrix:{type:"m4",value:null},config:{type:"v4",value:new Ne}},vertexShader:`

		#include <common>
		#include <fog_pars_vertex>
		#include <logdepthbuf_pars_vertex>

		uniform mat4 textureMatrix;

		varying vec4 vCoord;
		varying vec2 vUv;
		varying vec3 vToEye;

		void main() {

			vUv = uv;
			vCoord = textureMatrix * vec4( position, 1.0 );

			vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
			vToEye = cameraPosition - worldPosition.xyz;

			vec4 mvPosition =  viewMatrix * worldPosition; // used in fog_vertex
			gl_Position = projectionMatrix * mvPosition;

			#include <logdepthbuf_vertex>
			#include <fog_vertex>

		}`,fragmentShader:`

		#include <common>
		#include <fog_pars_fragment>
		#include <logdepthbuf_pars_fragment>

		uniform sampler2D tReflectionMap;
		uniform sampler2D tRefractionMap;
		uniform sampler2D tNormalMap0;
		uniform sampler2D tNormalMap1;

		#ifdef USE_FLOWMAP
			uniform sampler2D tFlowMap;
		#else
			uniform vec2 flowDirection;
		#endif

		uniform vec3 color;
		uniform float reflectivity;
		uniform vec4 config;

		varying vec4 vCoord;
		varying vec2 vUv;
		varying vec3 vToEye;

		void main() {

			#include <logdepthbuf_fragment>

			float flowMapOffset0 = config.x;
			float flowMapOffset1 = config.y;
			float halfCycle = config.z;
			float scale = config.w;

			vec3 toEye = normalize( vToEye );

			// determine flow direction
			vec2 flow;
			#ifdef USE_FLOWMAP
				flow = texture2D( tFlowMap, vUv ).rg * 2.0 - 1.0;
			#else
				flow = flowDirection;
			#endif
			flow.x *= - 1.0;

			// sample normal maps (distort uvs with flowdata)
			vec4 normalColor0 = texture2D( tNormalMap0, ( vUv * scale ) + flow * flowMapOffset0 );
			vec4 normalColor1 = texture2D( tNormalMap1, ( vUv * scale ) + flow * flowMapOffset1 );

			// linear interpolate to get the final normal color
			float flowLerp = abs( halfCycle - flowMapOffset0 ) / halfCycle;
			vec4 normalColor = mix( normalColor0, normalColor1, flowLerp );

			// calculate normal vector
			vec3 normal = normalize( vec3( normalColor.r * 2.0 - 1.0, normalColor.b,  normalColor.g * 2.0 - 1.0 ) );

			// calculate the fresnel term to blend reflection and refraction maps
			float theta = max( dot( toEye, normal ), 0.0 );
			float reflectance = reflectivity + ( 1.0 - reflectivity ) * pow( ( 1.0 - theta ), 5.0 );

			// calculate final uv coords
			vec3 coord = vCoord.xyz / vCoord.w;
			vec2 uv = coord.xy + coord.z * normal.xz * 0.05;

			vec4 reflectColor = texture2D( tReflectionMap, vec2( 1.0 - uv.x, uv.y ) );
			vec4 refractColor = texture2D( tRefractionMap, uv );

			// multiply water color with the mix of both textures
			gl_FragColor = vec4( color, 1.0 ) * mix( refractColor, reflectColor, reflectance );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>
			#include <fog_fragment>

		}`};const uo=(u,e,t={})=>{const{width:s=20,height:n=20,x:i=0,y:r=0,z:a=0,color:o="#ffffff",scale:c=4,flowX:h=1,flowY:l=1,normalMap0:d=void 0,normalMap1:p=void 0}=t,w=new lt(s,n),x=new Dt({color:30654,transparent:!0,opacity:.8}),y=new Ae(w,x);y.position.set(i,r,a),y.rotation.x=Math.PI*-.5,u.add(y);const T=new lt(s,n),_=new Nt(T,{color:o,scale:c,flowDirection:new Z(h,l),textureWidth:1024,textureHeight:1024,normalMap0:d,normalMap1:p});return _.position.set(i,r+.1,a),_.rotation.x=Math.PI*-.5,u.add(_),{ground:y,water:_}};class po{constructor(e,t,s){v(this,"scene");v(this,"renderer");v(this,"factories");this.scene=e,this.renderer=t,this.factories=s}water(e={}){uo(this.scene,this.renderer,e)}textureCube(e){e.length!==6&&Fe("You need to pass 6 urls to textureCube()");const t=new fo;return e.forEach((s,n)=>{s.wrapS=s.wrapT=je;const i=this.factories.add.material({phong:{map:s}});t.materials[n]=i}),t}}class fo{constructor(){v(this,"materials");this.materials=new Array(6)}get texture(){return{left:this.getTexture(0),right:this.getTexture(1),up:this.getTexture(2),down:this.getTexture(3),front:this.getTexture(4),back:this.getTexture(5)}}getTexture(e){return this.materials[e].map}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
 */class mo{constructor(e,t){v(this,"camera");v(this,"renderer");v(this,"tmpPlane");v(this,"tmpRaycaster");v(this,"tmpVector2",new Z);v(this,"tmpVector3");this.camera=e,this.renderer=t}fromSVGtoShape(e){if(e){const t=new ft,s=[];return t.parse(e).paths.forEach(n=>{ft.createShapes(n).forEach(i=>{s.push(i)})}),s}return[]}from3dto2d(e){const t=new G(e.x,e.y,e.z),s=this.renderer.domElement;this.camera.updateMatrixWorld(),t.project(this.camera);const n=Math.round((t.x+1)*(s.width/2)),i=Math.round((-t.y+1)*(s.height/2));return new Z(n,i)}from2dto3d(e,t,s){var a;if(!this.tmpPlane){const o=new lt(1e4,1e4),c=new De({transparent:!0,opacity:.25});this.tmpPlane=new Ae(o,c),this.tmpPlane.name="_tmp_raycast_plane"}this.tmpRaycaster||(this.tmpRaycaster=new fi),this.tmpVector3||(this.tmpVector3=new G);let n;this.tmpPlane.setRotationFromEuler(this.camera.rotation);const i=this.camera.position;this.tmpPlane.position.set(i.x,i.y,i.z),this.camera.getWorldDirection(this.tmpVector3),this.tmpPlane.position.add(this.tmpVector3.clone().multiplyScalar(s)),this.tmpPlane.updateMatrix(),this.tmpPlane.updateMatrixWorld(!0),this.tmpVector2.set(e,t),this.tmpRaycaster.setFromCamera(this.tmpVector2,this.camera);const r=this.tmpRaycaster.intersectObjects([this.tmpPlane]);return((a=r[0])==null?void 0:a.object.name)==="_tmp_raycast_plane"&&(n=r[0].point),n}}class rt{static createButton(e,t={}){const s=document.createElement("button");function n(){let c=null;async function h(p){p.addEventListener("end",l),await e.xr.setSession(p),s.textContent="EXIT VR",c=p}function l(){c.removeEventListener("end",l),s.textContent="ENTER VR",c=null}s.style.display="",s.style.cursor="pointer",s.style.left="calc(50% - 50px)",s.style.width="100px",s.textContent="ENTER VR";const d={...t,optionalFeatures:["local-floor","bounded-floor","layers",...t.optionalFeatures||[]]};s.onmouseenter=function(){s.style.opacity="1.0"},s.onmouseleave=function(){s.style.opacity="0.5"},s.onclick=function(){c===null?navigator.xr.requestSession("immersive-vr",d).then(h):(c.end(),navigator.xr.offerSession!==void 0&&navigator.xr.offerSession("immersive-vr",d).then(h).catch(p=>{console.warn(p)}))},navigator.xr.offerSession!==void 0&&navigator.xr.offerSession("immersive-vr",d).then(h).catch(p=>{console.warn(p)})}function i(){s.style.display="",s.style.cursor="auto",s.style.left="calc(50% - 75px)",s.style.width="150px",s.onmouseenter=null,s.onmouseleave=null,s.onclick=null}function r(){i(),s.textContent="VR NOT SUPPORTED"}function a(c){i(),console.warn("Exception when trying to call xr.isSessionSupported",c),s.textContent="VR NOT ALLOWED"}function o(c){c.style.position="absolute",c.style.bottom="20px",c.style.padding="12px 6px",c.style.border="1px solid #fff",c.style.borderRadius="4px",c.style.background="rgba(0,0,0,0.1)",c.style.color="#fff",c.style.font="normal 13px sans-serif",c.style.textAlign="center",c.style.opacity="0.5",c.style.outline="none",c.style.zIndex="999"}if("xr"in navigator)return s.id="VRButton",s.style.display="none",o(s),navigator.xr.isSessionSupported("immersive-vr").then(function(c){c?n():r(),c&&rt.xrSessionIsGranted&&s.click()}).catch(a),s;{const c=document.createElement("a");return window.isSecureContext===!1?(c.href=document.location.href.replace(/^http:/,"https:"),c.innerHTML="WEBXR NEEDS HTTPS"):(c.href="https://immersiveweb.dev/",c.innerHTML="WEBXR NOT AVAILABLE"),c.style.left="calc(50% - 90px)",c.style.width="180px",c.style.textDecoration="none",o(c),c}}static registerSessionGrantedListener(){if(typeof navigator<"u"&&"xr"in navigator){if(/WebXRViewer\//i.test(navigator.userAgent))return;navigator.xr.addEventListener("sessiongranted",()=>{rt.xrSessionIsGranted=!0})}}}rt.xrSessionIsGranted=!1;rt.registerSessionGrantedListener();const ue={ComponentState:Object.freeze({DEFAULT:"default",TOUCHED:"touched",PRESSED:"pressed"}),ComponentProperty:Object.freeze({BUTTON:"button",X_AXIS:"xAxis",Y_AXIS:"yAxis",STATE:"state"}),ComponentType:Object.freeze({TRIGGER:"trigger",SQUEEZE:"squeeze",TOUCHPAD:"touchpad",THUMBSTICK:"thumbstick",BUTTON:"button"}),ButtonTouchThreshold:.05,AxisTouchThreshold:.1,VisualResponseProperty:Object.freeze({TRANSFORM:"transform",VISIBILITY:"visibility"})};async function dn(u){const e=await fetch(u);if(e.ok)return e.json();throw new Error(e.statusText)}async function go(u){if(!u)throw new Error("No basePath supplied");return await dn(`${u}/profilesList.json`)}async function yo(u,e,t=null,s=!0){if(!u)throw new Error("No xrInputSource supplied");if(!e)throw new Error("No basePath supplied");const n=await go(e);let i;if(u.profiles.some(o=>{const c=n[o];return c&&(i={profileId:o,profilePath:`${e}/${c.path}`,deprecated:!!c.deprecated}),!!i}),!i){if(!t)throw new Error("No matching profile name found");const o=n[t];if(!o)throw new Error(`No matching profile name found and default profile "${t}" missing.`);i={profileId:t,profilePath:`${e}/${o.path}`,deprecated:!!o.deprecated}}const r=await dn(i.profilePath);let a;if(s){let o;if(u.handedness==="any"?o=r.layouts[Object.keys(r.layouts)[0]]:o=r.layouts[u.handedness],!o)throw new Error(`No matching handedness, ${u.handedness}, in profile ${i.profileId}`);o.assetPath&&(a=i.profilePath.replace("profile.json",o.assetPath))}return{profile:r,assetPath:a}}const xo={xAxis:0,yAxis:0,button:0,state:ue.ComponentState.DEFAULT};function wo(u=0,e=0){let t=u,s=e;if(Math.sqrt(u*u+e*e)>1){const r=Math.atan2(e,u);t=Math.cos(r),s=Math.sin(r)}return{normalizedXAxis:t*.5+.5,normalizedYAxis:s*.5+.5}}class bo{constructor(e){this.componentProperty=e.componentProperty,this.states=e.states,this.valueNodeName=e.valueNodeName,this.valueNodeProperty=e.valueNodeProperty,this.valueNodeProperty===ue.VisualResponseProperty.TRANSFORM&&(this.minNodeName=e.minNodeName,this.maxNodeName=e.maxNodeName),this.value=0,this.updateFromComponent(xo)}updateFromComponent({xAxis:e,yAxis:t,button:s,state:n}){const{normalizedXAxis:i,normalizedYAxis:r}=wo(e,t);switch(this.componentProperty){case ue.ComponentProperty.X_AXIS:this.value=this.states.includes(n)?i:.5;break;case ue.ComponentProperty.Y_AXIS:this.value=this.states.includes(n)?r:.5;break;case ue.ComponentProperty.BUTTON:this.value=this.states.includes(n)?s:0;break;case ue.ComponentProperty.STATE:this.valueNodeProperty===ue.VisualResponseProperty.VISIBILITY?this.value=this.states.includes(n):this.value=this.states.includes(n)?1:0;break;default:throw new Error(`Unexpected visualResponse componentProperty ${this.componentProperty}`)}}}class Ao{constructor(e,t){if(!e||!t||!t.visualResponses||!t.gamepadIndices||Object.keys(t.gamepadIndices).length===0)throw new Error("Invalid arguments supplied");this.id=e,this.type=t.type,this.rootNodeName=t.rootNodeName,this.touchPointNodeName=t.touchPointNodeName,this.visualResponses={},Object.keys(t.visualResponses).forEach(s=>{const n=new bo(t.visualResponses[s]);this.visualResponses[s]=n}),this.gamepadIndices=Object.assign({},t.gamepadIndices),this.values={state:ue.ComponentState.DEFAULT,button:this.gamepadIndices.button!==void 0?0:void 0,xAxis:this.gamepadIndices.xAxis!==void 0?0:void 0,yAxis:this.gamepadIndices.yAxis!==void 0?0:void 0}}get data(){return{id:this.id,...this.values}}updateFromGamepad(e){if(this.values.state=ue.ComponentState.DEFAULT,this.gamepadIndices.button!==void 0&&e.buttons.length>this.gamepadIndices.button){const t=e.buttons[this.gamepadIndices.button];this.values.button=t.value,this.values.button=this.values.button<0?0:this.values.button,this.values.button=this.values.button>1?1:this.values.button,t.pressed||this.values.button===1?this.values.state=ue.ComponentState.PRESSED:(t.touched||this.values.button>ue.ButtonTouchThreshold)&&(this.values.state=ue.ComponentState.TOUCHED)}this.gamepadIndices.xAxis!==void 0&&e.axes.length>this.gamepadIndices.xAxis&&(this.values.xAxis=e.axes[this.gamepadIndices.xAxis],this.values.xAxis=this.values.xAxis<-1?-1:this.values.xAxis,this.values.xAxis=this.values.xAxis>1?1:this.values.xAxis,this.values.state===ue.ComponentState.DEFAULT&&Math.abs(this.values.xAxis)>ue.AxisTouchThreshold&&(this.values.state=ue.ComponentState.TOUCHED)),this.gamepadIndices.yAxis!==void 0&&e.axes.length>this.gamepadIndices.yAxis&&(this.values.yAxis=e.axes[this.gamepadIndices.yAxis],this.values.yAxis=this.values.yAxis<-1?-1:this.values.yAxis,this.values.yAxis=this.values.yAxis>1?1:this.values.yAxis,this.values.state===ue.ComponentState.DEFAULT&&Math.abs(this.values.yAxis)>ue.AxisTouchThreshold&&(this.values.state=ue.ComponentState.TOUCHED)),Object.values(this.visualResponses).forEach(t=>{t.updateFromComponent(this.values)})}}class To{constructor(e,t,s){if(!e)throw new Error("No xrInputSource supplied");if(!t)throw new Error("No profile supplied");this.xrInputSource=e,this.assetUrl=s,this.id=t.profileId,this.layoutDescription=t.layouts[e.handedness],this.components={},Object.keys(this.layoutDescription.components).forEach(n=>{const i=this.layoutDescription.components[n];this.components[n]=new Ao(n,i)}),this.updateFromGamepad()}get gripSpace(){return this.xrInputSource.gripSpace}get targetRaySpace(){return this.xrInputSource.targetRaySpace}get data(){const e=[];return Object.values(this.components).forEach(t=>{e.push(t.data)}),e}updateFromGamepad(){Object.values(this.components).forEach(e=>{e.updateFromGamepad(this.xrInputSource.gamepad)})}}const vo="https://cdn.jsdelivr.net/npm/@webxr-input-profiles/assets@1.0/dist/profiles",Mo="generic-trigger";class So extends Ue{constructor(){super(),this.motionController=null,this.envMap=null}setEnvironmentMap(e){return this.envMap==e?this:(this.envMap=e,this.traverse(t=>{t.isMesh&&(t.material.envMap=this.envMap,t.material.needsUpdate=!0)}),this)}updateMatrixWorld(e){super.updateMatrixWorld(e),this.motionController&&(this.motionController.updateFromGamepad(),Object.values(this.motionController.components).forEach(t=>{Object.values(t.visualResponses).forEach(s=>{const{valueNode:n,minNode:i,maxNode:r,value:a,valueNodeProperty:o}=s;n&&(o===ue.VisualResponseProperty.VISIBILITY?n.visible=a:o===ue.VisualResponseProperty.TRANSFORM&&(n.quaternion.slerpQuaternions(i.quaternion,r.quaternion,a),n.position.lerpVectors(i.position,r.position,a)))})}))}}function Eo(u,e){Object.values(u.components).forEach(t=>{const{type:s,touchPointNodeName:n,visualResponses:i}=t;if(s===ue.ComponentType.TOUCHPAD)if(t.touchPointNode=e.getObjectByName(n),t.touchPointNode){const r=new kt(.001),a=new De({color:255}),o=new Ae(r,a);t.touchPointNode.add(o)}else console.warn(`Could not find touch dot, ${t.touchPointNodeName}, in touchpad component ${t.id}`);Object.values(i).forEach(r=>{const{valueNodeName:a,minNodeName:o,maxNodeName:c,valueNodeProperty:h}=r;if(h===ue.VisualResponseProperty.TRANSFORM){if(r.minNode=e.getObjectByName(o),r.maxNode=e.getObjectByName(c),!r.minNode){console.warn(`Could not find ${o} in the model`);return}if(!r.maxNode){console.warn(`Could not find ${c} in the model`);return}}r.valueNode=e.getObjectByName(a),r.valueNode||console.warn(`Could not find ${a} in the model`)})})}function Cs(u,e){Eo(u.motionController,e),u.envMap&&e.traverse(t=>{t.isMesh&&(t.material.envMap=u.envMap,t.material.needsUpdate=!0)}),u.add(e)}class _o{constructor(e=null,t=null){this.gltfLoader=e,this.path=vo,this._assetCache={},this.onLoad=t,this.gltfLoader||(this.gltfLoader=new cn)}setPath(e){return this.path=e,this}createControllerModel(e){const t=new So;let s=null;return e.addEventListener("connected",n=>{const i=n.data;i.targetRayMode!=="tracked-pointer"||!i.gamepad||i.hand||yo(i,this.path,Mo).then(({profile:r,assetPath:a})=>{t.motionController=new To(i,r,a);const o=this._assetCache[t.motionController.assetUrl];if(o)s=o.scene.clone(),Cs(t,s),this.onLoad&&this.onLoad(s);else{if(!this.gltfLoader)throw new Error("GLTFLoader not set.");this.gltfLoader.setPath(""),this.gltfLoader.load(t.motionController.assetUrl,c=>{this._assetCache[t.motionController.assetUrl]=c,s=c.scene.clone(),Cs(t,s),this.onLoad&&this.onLoad(s)},null,()=>{throw new Error(`Asset ${t.motionController.assetUrl} missing or malformed.`)})}}).catch(r=>{console.warn(r)})}),e.addEventListener("disconnected",()=>{t.motionController=null,t.remove(s),s=null}),t}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
 */class Po{constructor(e,t){v(this,"_renderer");v(this,"_scene");v(this,"cameraGroup");v(this,"controllerModelFactory",new _o);this._renderer=e,this._scene=t;const s=new bi;s.name="dot",this.cameraGroup=new st,this.cameraGroup.add(s),t.add(this.cameraGroup),e.xr.enabled=!0;const n=rt.createButton(e);n.style.cssText+="background: rgba(0, 0, 0, 0.8); ",document.body.appendChild(n),this._renderer.xr.getCamera().add(this.cameraGroup)}get isPresenting(){var e,t;return!!((t=(e=this._renderer)==null?void 0:e.xr)!=null&&t.isPresenting)}getController(e){const t=this._renderer.xr.getController(e);return this.cameraGroup.add(t),t}getControllerGrip(e){const t=this._renderer.xr.getControllerGrip(e),s=this.controllerModelFactory.createControllerModel(t);return t.add(s),this.cameraGroup.add(t),t}getControllerRay(e){const{targetRayMode:t}=e;if(t==="tracked-pointer"){const s=new ze;s.setAttribute("position",new Pe([0,0,0,0,0,-1],3)),s.setAttribute("color",new Pe([1,0,0,1,1,1],3));const n=new xt({vertexColors:!0});return new It(s,n)}if(t==="gaze"){const s=new mi(.02,.04,32).translate(0,0,-1),n=new De({color:"red",opacity:.5,transparent:!0});return new Ae(s,n)}}get camera(){return this.WebXRCamera}get WebXRCamera(){var e;return{group:this.cameraGroup,position:(e=this._renderer.xr.getCamera())==null?void 0:e.position,rotation:this.isPresenting?this._renderer.xr.getCamera().rotation:void 0,getWorldDirection:t=>this.isPresenting?this._renderer.xr.getCamera().getWorldDirection(t):void 0}}}const Ro=(u=20,e)=>{if(!window.__loadPhysics){console.log("There is not much fun without physics enabled!");return}for(let t=0;t<u;t++){const s=["standard","basic","normal","phong","line","points"],n=(r,a)=>Math.floor(Math.random()*(a-r+1)+r),i=r=>r[Math.floor(Math.random()*r.length)];Math.random()>.5?e.add.box({x:n(-10,10),y:n(10,20),z:n(-10,10),width:n(1,2)/10,height:n(1,2)/10,depth:n(1,2)/10,mass:1},{[i(s)]:{color:Math.floor(Math.random()*16777215)}}).body.setRestitution(Math.floor(Math.random()*10)/20):e.add.sphere({x:n(-10,10),y:n(10,20),z:n(-10,10),radius:n(1,2)/10,mass:1},{[i(s)]:{color:Math.floor(Math.random()*16777215)}}).body.setRestitution(Math.floor(Math.random()*10)/20)}};class Qt{constructor(e){this.top=0,this.array=new Float32Array(e)}write(e){this.array[this.top++]=e.x,this.array[this.top++]=e.y,this.array[this.top++]=e.z}}class Co{constructor(e){this.top=0,this.array=new Float32Array(e)}write(e){this.array[this.top++]=e.x,this.array[this.top++]=e.y}}class ke{constructor(e){this.plane=null,this.front=null,this.back=null,this.polygons=[],e&&this.build(e)}clone(){const e=new ke;return e.plane=this.plane&&this.plane.clone(),e.front=this.front&&this.front.clone(),e.back=this.back&&this.back.clone(),e.polygons=this.polygons.map(t=>t.clone()),e}invert(){for(let t=0;t<this.polygons.length;t++)this.polygons[t].flip();this.plane&&this.plane.flip(),this.front&&this.front.invert(),this.back&&this.back.invert();const e=this.front;this.front=this.back,this.back=e}clipPolygons(e){if(!this.plane)return e.slice();let t=new Array,s=new Array;for(let n=0;n<e.length;n++)this.plane.splitPolygon(e[n],t,s,t,s);return this.front&&(t=this.front.clipPolygons(t)),this.back?s=this.back.clipPolygons(s):s=[],t.concat(s)}clipTo(e){this.polygons=e.clipPolygons(this.polygons),this.front&&this.front.clipTo(e),this.back&&this.back.clipTo(e)}allPolygons(){let e=this.polygons.slice();return this.front&&(e=e.concat(this.front.allPolygons())),this.back&&(e=e.concat(this.back.allPolygons())),e}build(e){if(!e.length)return;this.plane||(this.plane=e[0].plane.clone());const t=[],s=[];for(let n=0;n<e.length;n++)this.plane.splitPolygon(e[n],this.polygons,this.polygons,t,s);t.length&&(this.front||(this.front=new ke),this.front.build(t)),s.length&&(this.back||(this.back=new ke),this.back.build(s))}}class Lt{constructor(e,t,s,n){this.pos=new qe().copy(e),this.normal=new qe().copy(t),this.uv=new qe().copy(s),this.uv.z=0,n&&(this.color=new qe().copy(n))}clone(){return new Lt(this.pos,this.normal,this.uv,this.color)}flip(){this.normal.negate()}interpolate(e,t){return new Lt(this.pos.clone().lerp(e.pos,t),this.normal.clone().lerp(e.normal,t),this.uv.clone().lerp(e.uv,t),this.color&&e.color&&this.color.clone().lerp(e.color,t))}}class he{constructor(){this.polygons=[]}static fromPolygons(e){const t=new he;return t.polygons=e,t}static fromGeometry(e,t){let s=[];const n=e.attributes.position,i=e.attributes.normal,r=e.attributes.uv,a=e.attributes.color,o=e.groups;let c;if(e.index)c=e.index.array;else{c=new Uint16Array(n.array.length/n.itemSize|0);for(let l=0;l<c.length;l++)c[l]=l}const h=c.length/3|0;s=new Array(h);for(let l=0,d=0,p=c.length;l<p;l+=3,d++){const w=new Array(3);for(let x=0;x<3;x++){const y=c[l+x],T=y*3,_=y*2,b=n.array[T],S=n.array[T+1],P=n.array[T+2],C=i.array[T],D=i.array[T+1],k=i.array[T+2],B=r==null?void 0:r.array[_],O=r==null?void 0:r.array[_+1];w[x]=new Lt(new qe(b,S,P),new qe(C,D,k),new qe(B,O,0),a&&new qe(a.array[T],a.array[T+1],a.array[T+2]))}if(t===void 0&&o&&o.length>0)for(const x of o)l>=x.start&&l<x.start+x.count&&(s[d]=new xs(w,x.materialIndex));else s[d]=new xs(w,t)}return he.fromPolygons(s.filter(l=>!Number.isNaN(l.plane.normal.x)))}static toGeometry(e,t){let s=0;const n=e.polygons;for(const p of n)s+=p.vertices.length-2;const i=new ze,r=new Qt(s*3*3),a=new Qt(s*3*3),o=new Co(s*2*3);let c;const h=[],l=[];for(const p of n){const w=p.vertices,x=w.length;p.shared!==void 0&&(h[p.shared]||(h[p.shared]=[])),x&&w[0].color!==void 0&&(c||(c=new Qt(s*3*3)));for(let y=3;y<=x;y++)(p.shared===void 0?l:h[p.shared]).push(r.top/3,r.top/3+1,r.top/3+2),r.write(w[0].pos),r.write(w[y-2].pos),r.write(w[y-1].pos),a.write(w[0].normal),a.write(w[y-2].normal),a.write(w[y-1].normal),o&&(o.write(w[0].uv),o.write(w[y-2].uv),o.write(w[y-1].uv)),c&&(c.write(w[0].color),c.write(w[y-2].color),c.write(w[y-1].color))}i.setAttribute("position",new Oe(r.array,3)),i.setAttribute("normal",new Oe(a.array,3)),o&&i.setAttribute("uv",new Oe(o.array,2)),c&&i.setAttribute("color",new Oe(c.array,3));for(let p=0;p<h.length;p++)h[p]===void 0&&(h[p]=[]);if(h.length){let p=[],w=0;for(let x=0;x<h.length;x++)i.addGroup(w,h[x].length,x),w+=h[x].length,p=p.concat(h[x]);i.addGroup(w,l.length,h.length),p=p.concat(l),i.setIndex(p)}const d=new se().copy(t).invert();return i.applyMatrix4(d),i.computeBoundingSphere(),i.computeBoundingBox(),i}static fromMesh(e,t){const s=he.fromGeometry(e.geometry,t),n=new G,i=new Ke;i.getNormalMatrix(e.matrix);for(let r=0;r<s.polygons.length;r++){const a=s.polygons[r];for(let o=0;o<a.vertices.length;o++){const c=a.vertices[o];c.pos.copy(n.copy(c.pos.toVector3()).applyMatrix4(e.matrix)),c.normal.copy(n.copy(c.normal.toVector3()).applyMatrix3(i))}}return s}static toMesh(e,t,s){const n=he.toGeometry(e,t),i=new Ae(n,s);return i.matrix.copy(t),i.matrix.decompose(i.position,i.quaternion,i.scale),i.rotation.setFromQuaternion(i.quaternion),i.updateMatrixWorld(),i.castShadow=i.receiveShadow=!0,i}static union(e,t){const s=he.fromMesh(e),n=he.fromMesh(t);return he.toMesh(s.union(n),e.matrix,e.material)}static subtract(e,t){const s=he.fromMesh(e),n=he.fromMesh(t);return he.toMesh(s.subtract(n),e.matrix,e.material)}static intersect(e,t){const s=he.fromMesh(e),n=he.fromMesh(t);return he.toMesh(s.intersect(n),e.matrix,e.material)}clone(){const e=new he;return e.polygons=this.polygons.map(t=>t.clone()).filter(t=>Number.isFinite(t.plane.w)),e}toPolygons(){return this.polygons}union(e){const t=new ke(this.clone().polygons),s=new ke(e.clone().polygons);return t.clipTo(s),s.clipTo(t),s.invert(),s.clipTo(t),s.invert(),t.build(s.allPolygons()),he.fromPolygons(t.allPolygons())}subtract(e){const t=new ke(this.clone().polygons),s=new ke(e.clone().polygons);return t.invert(),t.clipTo(s),s.clipTo(t),s.invert(),s.clipTo(t),s.invert(),t.build(s.allPolygons()),t.invert(),he.fromPolygons(t.allPolygons())}intersect(e){const t=new ke(this.clone().polygons),s=new ke(e.clone().polygons);return t.invert(),s.clipTo(t),s.invert(),t.clipTo(s),s.clipTo(t),t.build(s.allPolygons()),t.invert(),he.fromPolygons(t.allPolygons())}inverse(){const e=this.clone();for(const t of e.polygons)t.flip();return e}toMesh(e,t){return he.toMesh(this,e,t)}toGeometry(e){return he.toGeometry(this,e)}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2022 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
 */class Lo{static union(e,t){return this.doCSG(e,t,"union")}static subtract(e,t){return this.doCSG(e,t,"subtract")}static intersect(e,t){return this.doCSG(e,t,"intersect")}static doCSG(e,t,s){if(e.updateMatrix(),t.updateMatrix(),s==="union")return he.union(e,t);if(s==="subtract")return he.subtract(e,t);if(s==="intersect")return he.intersect(e,t)}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
 */class Io extends _i{constructor(t,s={}){var h;const n=document.getElementById("enable3d-three-canvas");let i={};n&&(i={canvas:n}),s.renderer=new Fs({...i,antialias:s.antialias||!1});super(s);v(this,"scene3D");v(this,"isXrEnabled");v(this,"composer");v(this,"load");v(this,"lights");v(this,"transform");v(this,"heightMap");v(this,"webXR");v(this,"misc");v(this,"cameras");v(this,"csg");v(this,"factories");v(this,"ws");v(this,"mixers");(h=t.sys.game.canvas.parentElement)==null||h.insertBefore(s.renderer.domElement,t.sys.game.canvas),t.sys.game.canvas.style.position="relative";const r=()=>{var x,y;if(!s.renderer)return;const{width:l,height:d,marginLeft:p,marginTop:w}=t.sys.game.canvas.style;s.renderer.domElement.id="enable3d-three-canvas",(x=this.camera)!=null&&x.aspect&&(this.camera.aspect=t.sys.game.scale.baseSize.width/t.sys.game.scale.baseSize.height),(y=this.camera)==null||y.updateProjectionMatrix(),s.renderer.setSize(t.sys.game.scale.baseSize.width,t.sys.game.scale.baseSize.height),s.renderer.domElement.style.width=l,s.renderer.domElement.style.height=d,s.renderer.domElement.style.marginLeft=p,s.renderer.domElement.style.marginTop=w};r(),t.scale.on("resize",()=>{r()});const a=document.createElement("style");a.innerText=`
      #enable3d-phaser-canvas:focus,
      #enable3d-three-canvas:focus {
        outline: none;
      }

      #enable3d-three-canvas {
        position: absolute;
      }
    `,document.head.appendChild(a);const{enableXR:o=!1}=s;if(this.isXrEnabled=o,this.scene3D=t,o&&(this.webXR=new Po(this.renderer,this.scene)),this.isXrEnabled){let l=0;this.renderer.setAnimationLoop(d=>{if(this.renderer.xr.isPresenting){const p=d-l;l=d,t.updateLoopXR(d,p),this.renderer.state.reset(),this.preRender(),this.composer?this.composer.render():this.renderer.render(this.scene,this.camera),this.postRender()}})}const c=t.add.extern();c.render=l=>{this.renderer.xr.isPresenting||(this.preRender(),this.composer?this.composer.render():this.renderer.render(this.scene,this.camera),this.postRender())},t.events.on("postupdate",(l,d)=>{var p,w,x;(p=this.animationMixers)==null||p.update(d),(w=this.physics)==null||w.update(d),(x=this.physics)==null||x.updateDebugger()}),this.load=new Wr(this.cache,this.textureAnisotropy),this.lights=new Kr(this.scene),this.transform=new mo(this.camera,this.renderer),this.csg=Lo,this.heightMap=new qr(this.scene),this.factories=new Qs(this.scene),this.misc=new po(this.scene,this.renderer,this.factories),this.cameras=new dt,this.ws=new lo(this.scene,this.renderer,this.camera,this.lights,this.physics,this.load,this.factories),this.mixers=new ho,t.events.once("shutdown",()=>{t.clearThirdDimension(),t.events.removeListener("update")})}preRender(){}postRender(){}destroy(t){this.physics.destroy(t),this.scene.remove(t),t=null}async warpSpeed(...t){return await this.ws.warpSpeed(...t)}haveSomeFun(t=20){Ro(t,this.physics)}get animationMixers(){var t;return(t=this.mixers)==null?void 0:t.mixers}get make(){return this.factories.make}get add(){return this.factories.add}}/**
 * @author       Yannick Deubel (https://github.com/yandeu)
 * @copyright    Copyright (c) 2020 Yannick Deubel; Project Url: https://github.com/enable3d/enable3d
 * @license      {@link https://github.com/enable3d/enable3d/blob/master/LICENSE|LGPL-3.0}
 */class ko extends gi.Scene{constructor(t){super(t);v(this,"third")}async warpSpeed(...t){return await this.third.warpSpeed(...t)}haveSomeFun(t=20){this.third.haveSomeFun(t)}requestThirdDimension(){Fe("You do not need requestThirdDimension() anymore. Place accessThirdDimension() inside init() instead!")}clearThirdDimension(){for(const t in this.third)delete this.third[t];delete this.third}accessThirdDimension(t={}){this.clearThirdDimension(),this.third=new Io(this,t),this.cameras.main.transparent=!0,this.cameras.main.setBackgroundColor("rgba(0,0,0,0)"),this.third.scene.background=new oe("white")}updateLoopXR(t,s){this.preUpdateXR(t,s),this.updateXR(t,s),this.postUpdateXR(t,s)}preUpdateXR(t,s){}updateXR(t,s){}postUpdateXR(t,s){this.third.isXrEnabled&&(this.time.update(t,s),this.third.physics.update(s),this.third.physics.updateDebugger(),this.third.animationMixers.update(s))}}class Fo extends ko{constructor(){super({key:"SubwayScene"}),this.colliders=[],this.collidersVisible=!1,this.flyMode=!1,this.wallColliders=[],this.floorColliders=[],this.ceilingColliders=[],this.stairColliders=[],this.isGrounded=!1,this.verticalVelocity=0,this.gravity=-30,this.jumpForce=8,this.maxStepHeight=.4,this.guns=[]}init(){this.accessThirdDimension({gravity:{y:0}})}preload(){this.load.audio("background","assets/sound effects/untitled.ogg")}async create(){this.third.lights.ambientLight({intensity:.5});const e=await this.third.load.gltf("/assets/models/SubwayScene.glb");this.backgroundMusic=this.sound.add("background",{loop:!0,volume:.5}),this.backgroundMusic.play();const t=e.scene;t.updateMatrixWorld(!0),this.third.add.existing(t),t.traverse(s=>{var l;if(!s.isMesh)return;const n=s.name.toLowerCase(),i=((l=s.userData.tag)==null?void 0:l.toLowerCase())||"";if(i==="gun"&&this.guns.push(s),n.includes("wallart")||n.includes("turnstile")||!(n.includes("fixed_phys")||n.includes("collider")||n.includes("floor")||n.includes("wall")||n.includes("stairs")))return;const a=new Ze().setFromObject(s),o=new G,c=new G;if(a.getSize(o),a.getCenter(c),o.x<.05||o.y<.05||o.z<.05)return;const h=this.third.add.box({x:c.x,y:c.y,z:c.z,width:o.x,height:o.y,depth:o.z},{lambert:{color:16711935,transparent:!0,opacity:0},mass:0});h.visible=!1,this.colliders.push(h),i.includes("wall")&&this.wallColliders.push(h),i.includes("floor")&&this.floorColliders.push(h),i.includes("ceiling")&&this.ceilingColliders.push(h),i.includes("stairs")&&this.stairColliders.push(h)}),this.player=this.third.add.box({x:0,y:2,z:0,width:.6,height:1.8,depth:.6},{lambert:{color:65280,transparent:!0,opacity:0}}),this.player.visible=!1,this.cameraHeightOffset=1,this.third.camera.position.set(0,2+this.cameraHeightOffset,5),this.third.camera.lookAt(this.player.position),this.keys=this.input.keyboard.addKeys("W,A,S,D,SPACE,E"),this.walkSpeed=5,this.flySpeed=.2,this.yaw=0,this.pitch=0,this.input.mouse.requestPointerLock(),this.input.on("pointerdown",()=>{this.input.mouse.locked||this.input.mouse.requestPointerLock()}),this.input.on("pointermove",s=>{if(this.input.mouse.locked){this.yaw-=s.movementX*.002,this.pitch-=s.movementY*.002;const i=Math.PI/2-.1,r=-Math.PI/2+.1;this.pitch=Phaser.Math.Clamp(this.pitch,r,i)}})}update(){if(!this.keys||!this.player)return;this.isGrounded=!1;let e=new G(0,0,0);this.keys.W.isDown&&(e.z=-1),this.keys.S.isDown&&(e.z=1),this.keys.A.isDown&&(e.x=-1),this.keys.D.isDown&&(e.x=1),e.normalize(),e.applyAxisAngle(new G(0,1,0),this.yaw);let t=new G(e.x*this.walkSpeed*this.game.loop.delta/1e3,0,e.z*this.walkSpeed*this.game.loop.delta/1e3);const s=this.player.position.clone().add(t),n=new Ze().setFromCenterAndSize(s,new G(.5,1.8,.5));for(const a of this.wallColliders){const o=new Ze().setFromObject(a);o.expandByScalar(.05),n.intersectsBox(o)&&(Math.abs(t.x)>Math.abs(t.z)?t.x=0:t.z=0)}this.player.position.add(t),this.verticalVelocity+=this.gravity*this.game.loop.delta/1e3,this.player.position.y+=this.verticalVelocity*this.game.loop.delta/1e3;const i=new Ze().setFromCenterAndSize(this.player.position,new G(.5,1.8,.5)),r=(a,o)=>{for(const c of a){const h=new Ze().setFromObject(c);if(h.expandByScalar(.05),i.intersectsBox(h)){if(o==="FLOOR"||o==="STAIRS"){this.isGrounded=!0;const l=h.max.y+.9;this.player.position.y<l+this.maxStepHeight&&(this.player.position.y=Math.max(this.player.position.y,l),this.verticalVelocity=0)}o==="CEILING"&&this.verticalVelocity>0&&(this.verticalVelocity=0)}}};if(r(this.floorColliders,"FLOOR"),r(this.stairColliders,"STAIRS"),r(this.ceilingColliders,"CEILING"),this.isGrounded&&Phaser.Input.Keyboard.JustDown(this.keys.SPACE)&&(this.verticalVelocity=this.jumpForce),this.third.camera.position.set(this.player.position.x,this.player.position.y+this.cameraHeightOffset,this.player.position.z),this.third.camera.rotation.order="YXZ",this.third.camera.rotation.y=this.yaw,this.third.camera.rotation.x=this.pitch,this.guns.forEach(a=>{const o=this.player.position,c=a.getWorldPosition(new G);o.distanceTo(c)<2?a.material&&(a.material.emissive=new oe(65280),a.material.emissiveIntensity=1):a.material&&(a.material.emissive=new oe(0),a.material.emissiveIntensity=0)}),Phaser.Input.Keyboard.JustDown(this.keys.E)){const a=this.player.position;this.guns.forEach(o=>{const c=o.getWorldPosition(new G);a.distanceTo(c)<2&&(this.backgroundMusic&&this.backgroundMusic.stop(),this.scene.stop("SubwayScene"),this.scene.start("TransitionScene"))})}}}export{Fo as default};
